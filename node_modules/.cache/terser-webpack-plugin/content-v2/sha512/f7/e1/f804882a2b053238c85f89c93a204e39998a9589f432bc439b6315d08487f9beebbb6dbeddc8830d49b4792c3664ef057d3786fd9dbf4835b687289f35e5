{"map":"{\"version\":3,\"sources\":[\"js/npm.v-currency-field.js\"],\"names\":[\"self\",\"this\",\"push\",\"./node_modules/v-currency-field/dist/v-currency-field.esm.js\",\"module\",\"__webpack_exports__\",\"__webpack_require__\",\"eval\"],\"mappings\":\"EAAkB,qBAATA,KAAuBA,KAAOC,MAAM,iBAAmC,qBAATD,KAAuBA,KAAOC,MAAM,iBAAmB,IAAIC,KAAK,CAAC,CAAC,wBAAwB,CAE3JC;;;;kEAKA,SAAUC,OAAQC,oBAAqBC,qBAE7C,aACAC,KAAK\"}","code":"((\"undefined\"!==typeof self?self:this)[\"webpackJsonp\"]=(\"undefined\"!==typeof self?self:this)[\"webpackJsonp\"]||[]).push([[\"npm.v-currency-field\"],{\"./node_modules/v-currency-field/dist/v-currency-field.esm.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/v-currency-field/dist/v-currency-field.esm.js ***!\n  \\********************************************************************/\n/*! exports provided: default, VCurrencyField, options, version */function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"VCurrencyField\\\", function() { return VCurrencyField; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"options\\\", function() { return options; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"version\\\", function() { return version; });\\n/*!\\n * v-currency-field v3.1.1 \\n * (c) 2020 Philipe Augusto <phiny1@gmail.com>\\n * Released under the MIT License.\\n */\\nfunction _typeof(obj) {\\n  \\\"@babel/helpers - typeof\\\";\\n\\n  if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") {\\n    _typeof = function (obj) {\\n      return typeof obj;\\n    };\\n  } else {\\n    _typeof = function (obj) {\\n      return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj;\\n    };\\n  }\\n\\n  return _typeof(obj);\\n}\\n\\nfunction _defineProperty(obj, key, value) {\\n  if (key in obj) {\\n    Object.defineProperty(obj, key, {\\n      value: value,\\n      enumerable: true,\\n      configurable: true,\\n      writable: true\\n    });\\n  } else {\\n    obj[key] = value;\\n  }\\n\\n  return obj;\\n}\\n\\nfunction ownKeys(object, enumerableOnly) {\\n  var keys = Object.keys(object);\\n\\n  if (Object.getOwnPropertySymbols) {\\n    var symbols = Object.getOwnPropertySymbols(object);\\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\\n    });\\n    keys.push.apply(keys, symbols);\\n  }\\n\\n  return keys;\\n}\\n\\nfunction _objectSpread2(target) {\\n  for (var i = 1; i < arguments.length; i++) {\\n    var source = arguments[i] != null ? arguments[i] : {};\\n\\n    if (i % 2) {\\n      ownKeys(Object(source), true).forEach(function (key) {\\n        _defineProperty(target, key, source[key]);\\n      });\\n    } else if (Object.getOwnPropertyDescriptors) {\\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\\n    } else {\\n      ownKeys(Object(source)).forEach(function (key) {\\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\\n      });\\n    }\\n  }\\n\\n  return target;\\n}\\n\\nfunction _objectWithoutPropertiesLoose(source, excluded) {\\n  if (source == null) return {};\\n  var target = {};\\n  var sourceKeys = Object.keys(source);\\n  var key, i;\\n\\n  for (i = 0; i < sourceKeys.length; i++) {\\n    key = sourceKeys[i];\\n    if (excluded.indexOf(key) >= 0) continue;\\n    target[key] = source[key];\\n  }\\n\\n  return target;\\n}\\n\\nfunction _objectWithoutProperties(source, excluded) {\\n  if (source == null) return {};\\n\\n  var target = _objectWithoutPropertiesLoose(source, excluded);\\n\\n  var key, i;\\n\\n  if (Object.getOwnPropertySymbols) {\\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\\n\\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\\n      key = sourceSymbolKeys[i];\\n      if (excluded.indexOf(key) >= 0) continue;\\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\\n      target[key] = source[key];\\n    }\\n  }\\n\\n  return target;\\n}\\n\\nvar dispatchEvent = (function (el, eventName, data) {\\n  var event = document.createEvent('CustomEvent');\\n  event.initCustomEvent(eventName, true, true, data);\\n  el.dispatchEvent(event);\\n});\\n\\n/**\\n * Sets the value of an input programmatically.\\n *\\n * @param {HTMLInputElement} el The input element the `v-currency` directive is bound to.\\n * @param {Number} value The number to be set.\\n */\\n\\nvar setValue = function setValue(el, value) {\\n  return dispatchEvent(el, 'format', {\\n    value: value\\n  });\\n};\\n\\n/**\\n * Vue Currency Input 1.21.0\\n * (c) 2018-2020 Matthias Stiller\\n * @license MIT\\n */\\nfunction dispatchEvent$1(el, eventName, data) {\\n  var event = document.createEvent('CustomEvent');\\n  event.initCustomEvent(eventName, true, true, data);\\n  el.dispatchEvent(event);\\n}\\n\\nvar toExternalNumberModel = function toExternalNumberModel(number, valueAsInteger, fractionDigits) {\\n  return valueAsInteger && number != null ? Number(number.toFixed(fractionDigits).split('.').join('')) : number;\\n};\\n\\nvar DEFAULT_OPTIONS = {\\n  locale: undefined,\\n  currency: 'EUR',\\n  valueAsInteger: false,\\n  distractionFree: true,\\n  precision: undefined,\\n  autoDecimalMode: false,\\n  valueRange: undefined,\\n  allowNegative: true\\n};\\n\\nvar getValue = function getValue(el) {\\n  var ref = el.$ci;\\n  var numberValue = ref.numberValue;\\n  var currencyFormat = ref.currencyFormat;\\n  var options = ref.options;\\n  return toExternalNumberModel(numberValue, options.valueAsInteger, currencyFormat.maximumFractionDigits);\\n};\\n\\nvar setValue$1 = function setValue(el, value) {\\n  return dispatchEvent$1(el, 'format', {\\n    value: value\\n  });\\n};\\n\\nvar escapeRegExp = function escapeRegExp(str) {\\n  return str.replace(/[.*+?^${}()|[\\\\]\\\\\\\\]/g, '\\\\\\\\$&');\\n};\\n\\nvar removeLeadingZeros = function removeLeadingZeros(str) {\\n  return str.replace(/^0+(0$|[^0])/, '$1');\\n};\\n\\nvar count = function count(str, search) {\\n  return (str.match(new RegExp(escapeRegExp(search), 'g')) || []).length;\\n};\\n\\nvar startsWith = function startsWith(str, search) {\\n  return str.substring(0, search.length) === search;\\n};\\n\\nvar substringBefore = function substringBefore(str, search) {\\n  return str.substring(0, str.indexOf(search));\\n};\\n\\nvar setCaretPosition = function setCaretPosition(el, position) {\\n  return el.setSelectionRange(position, position);\\n};\\n\\nvar getCaretPositionAfterFormat = function getCaretPositionAfterFormat(newValue, inputtedValue, caretPosition, numberFormat, options) {\\n  var prefix = numberFormat.prefix;\\n  var suffix = numberFormat.suffix;\\n  var decimalSymbol = numberFormat.decimalSymbol;\\n  var maximumFractionDigits = numberFormat.maximumFractionDigits;\\n  var groupingSymbol = numberFormat.groupingSymbol;\\n  var decimalSymbolPosition = inputtedValue.indexOf(decimalSymbol) + 1;\\n  var caretPositionFromLeft = inputtedValue.length - caretPosition;\\n\\n  if (Math.abs(newValue.length - inputtedValue.length) > 1 && caretPosition <= decimalSymbolPosition) {\\n    return newValue.indexOf(decimalSymbol) + 1;\\n  } else if (newValue.substr(caretPosition, 1) === groupingSymbol && count(newValue, groupingSymbol) === count(inputtedValue, groupingSymbol) + 1) {\\n    return newValue.length - caretPositionFromLeft - 1;\\n  } else {\\n    if (!options.autoDecimalMode && decimalSymbolPosition !== 0 && caretPosition > decimalSymbolPosition) {\\n      if (numberFormat.onlyDigits(inputtedValue.substr(decimalSymbolPosition)).length - 1 === maximumFractionDigits) {\\n        caretPositionFromLeft -= 1;\\n      }\\n    }\\n\\n    return options.distractionFree.hideCurrencySymbol ? newValue.length - caretPositionFromLeft : Math.max(newValue.length - Math.max(caretPositionFromLeft, suffix.length), prefix.length === 0 ? 0 : prefix.length + 1);\\n  }\\n};\\n\\nvar getDistractionFreeCaretPosition = function getDistractionFreeCaretPosition(numberFormat, options, value, caretPosition) {\\n  var result = caretPosition;\\n\\n  if (options.distractionFree.hideCurrencySymbol) {\\n    result -= numberFormat.prefix.length;\\n  }\\n\\n  if (options.distractionFree.hideGroupingSymbol) {\\n    result -= count(value.substring(0, caretPosition), numberFormat.groupingSymbol);\\n  }\\n\\n  return Math.max(0, result);\\n};\\n\\nvar equal = function equal(a, b) {\\n  if (a === b) {\\n    return true;\\n  }\\n\\n  if (!a || !b || _typeof(a) !== 'object' || _typeof(b) !== 'object') {\\n    return false;\\n  }\\n\\n  var keys = Object.keys(a);\\n\\n  if (keys.length !== Object.keys(b).length) {\\n    return false;\\n  }\\n\\n  if (!keys.every(Object.prototype.hasOwnProperty.bind(b))) {\\n    return false;\\n  }\\n\\n  return keys.every(function (key) {\\n    return equal(a[key], b[key]);\\n  });\\n};\\n\\nvar DECIMAL_SYMBOLS = [',', '.', 'Ù«'];\\n\\nvar NumberFormat = function NumberFormat(options) {\\n  var currency = options.currency;\\n  var locale = options.locale;\\n  var precision = options.precision;\\n  var autoDecimalMode = options.autoDecimalMode;\\n  var valueAsInteger = options.valueAsInteger;\\n  var numberFormat = new Intl.NumberFormat(locale, typeof currency === 'string' ? {\\n    currency: currency,\\n    style: 'currency'\\n  } : {\\n    minimumFractionDigits: 1\\n  });\\n  var ps = numberFormat.format(123456);\\n  this.locale = locale;\\n  this.currency = currency;\\n  this.digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (i) {\\n    return i.toLocaleString(locale);\\n  });\\n  this.decimalSymbol = count(ps, this.digits[0]) ? ps.substr(ps.indexOf(this.digits[6]) + 1, 1) : undefined;\\n  this.groupingSymbol = ps.substr(ps.indexOf(this.digits[3]) + 1, 1);\\n  this.minusSymbol = substringBefore(Number(-1).toLocaleString(locale), this.digits[1]);\\n\\n  if (this.decimalSymbol === undefined) {\\n    this.minimumFractionDigits = this.maximumFractionDigits = 0;\\n  } else if (typeof precision === 'number') {\\n    this.minimumFractionDigits = this.maximumFractionDigits = precision;\\n  } else if (_typeof(precision) === 'object' && !autoDecimalMode && !valueAsInteger) {\\n    this.minimumFractionDigits = precision.min || 0;\\n    this.maximumFractionDigits = precision.max !== undefined ? precision.max : 20;\\n  } else if (typeof currency === 'string') {\\n    this.minimumFractionDigits = numberFormat.resolvedOptions().minimumFractionDigits;\\n    this.maximumFractionDigits = numberFormat.resolvedOptions().maximumFractionDigits;\\n  } else {\\n    this.minimumFractionDigits = this.maximumFractionDigits = 2;\\n  }\\n\\n  if (typeof currency === 'string') {\\n    this.prefix = substringBefore(ps, this.digits[1]);\\n    this.negativePrefix = substringBefore(numberFormat.format(-1), this.digits[1]);\\n    this.suffix = ps.substring(ps.lastIndexOf(this.decimalSymbol ? this.digits[0] : this.digits[6]) + 1);\\n  } else {\\n    this.prefix = (currency || {}).prefix || '';\\n    this.negativePrefix = \\\"\\\" + this.minusSymbol + this.prefix;\\n    this.suffix = (currency || {}).suffix || '';\\n  }\\n};\\n\\nNumberFormat.prototype.parse = function parse(str) {\\n  var negative = this.isNegative(str);\\n  str = this.normalizeDigits(str);\\n  str = this.stripCurrencySymbol(str);\\n  str = this.stripMinusSymbol(str);\\n  var fraction = this.decimalSymbol ? \\\"(\\\" + escapeRegExp(this.decimalSymbol) + \\\"\\\\\\\\d*)?\\\" : '';\\n  var match = str.match(new RegExp(\\\"^\\\" + this.integerPattern() + fraction + \\\"$\\\"));\\n\\n  if (match) {\\n    return Number(\\\"\\\" + (negative ? '-' : '') + this.onlyDigits(match[1]) + \\\".\\\" + this.onlyDigits(match[3] || ''));\\n  }\\n\\n  return null;\\n};\\n\\nNumberFormat.prototype.format = function format(number, options) {\\n  if (options === void 0) options = {\\n    minimumFractionDigits: this.minimumFractionDigits,\\n    maximumFractionDigits: this.maximumFractionDigits\\n  };\\n\\n  if (typeof this.currency === 'string') {\\n    return number.toLocaleString(this.locale, Object.assign({}, {\\n      style: 'currency',\\n      currency: this.currency\\n    }, options));\\n  } else {\\n    return this.insertCurrencySymbol(Math.abs(number).toLocaleString(this.locale, options), number < 0 || number === 0 && 1 / number < 0);\\n  }\\n};\\n\\nNumberFormat.prototype.integerPattern = function integerPattern() {\\n  return \\\"(0|[1-9]\\\\\\\\d{0,2}(\\\" + escapeRegExp(this.groupingSymbol) + \\\"?\\\\\\\\d{3})*)\\\";\\n};\\n\\nNumberFormat.prototype.toFraction = function toFraction(str) {\\n  return \\\"\\\" + this.digits[0] + this.decimalSymbol + this.onlyLocaleDigits(str.substr(1)).substr(0, this.maximumFractionDigits);\\n};\\n\\nNumberFormat.prototype.isFractionIncomplete = function isFractionIncomplete(str) {\\n  return !!this.normalizeDigits(str).match(new RegExp(\\\"^\\\" + this.integerPattern() + escapeRegExp(this.decimalSymbol) + \\\"$\\\"));\\n};\\n\\nNumberFormat.prototype.isNegative = function isNegative(str) {\\n  return startsWith(str, this.negativePrefix) || startsWith(str.replace('-', this.minusSymbol), this.minusSymbol);\\n};\\n\\nNumberFormat.prototype.insertCurrencySymbol = function insertCurrencySymbol(str, negative) {\\n  return \\\"\\\" + (negative ? this.negativePrefix : this.prefix) + str + this.suffix;\\n};\\n\\nNumberFormat.prototype.stripMinusSymbol = function stripMinusSymbol(str) {\\n  return str.replace('-', this.minusSymbol).replace(this.minusSymbol, '');\\n};\\n\\nNumberFormat.prototype.stripCurrencySymbol = function stripCurrencySymbol(str) {\\n  return str.replace(this.negativePrefix, '').replace(this.prefix, '').replace(this.suffix, '');\\n};\\n\\nNumberFormat.prototype.normalizeDecimalSymbol = function normalizeDecimalSymbol(str, from) {\\n  var this$1 = this;\\n  DECIMAL_SYMBOLS.forEach(function (s) {\\n    str = str.substr(0, from) + str.substr(from).replace(s, this$1.decimalSymbol);\\n  });\\n  return str;\\n};\\n\\nNumberFormat.prototype.normalizeDigits = function normalizeDigits(str) {\\n  if (this.digits[0] !== '0') {\\n    this.digits.forEach(function (digit, index) {\\n      str = str.replace(new RegExp(digit, 'g'), index);\\n    });\\n  }\\n\\n  return str;\\n};\\n\\nNumberFormat.prototype.onlyDigits = function onlyDigits(str) {\\n  return this.normalizeDigits(str).replace(/\\\\D+/g, '');\\n};\\n\\nNumberFormat.prototype.onlyLocaleDigits = function onlyLocaleDigits(str) {\\n  return str.replace(new RegExp(\\\"[^\\\" + this.digits.join('') + \\\"]*\\\", 'g'), '');\\n};\\n\\nvar DefaultNumberMask = function DefaultNumberMask(numberFormat) {\\n  this.numberFormat = numberFormat;\\n};\\n\\nDefaultNumberMask.prototype.conformToMask = function conformToMask(str, previousConformedValue) {\\n  var this$1 = this;\\n  if (previousConformedValue === void 0) previousConformedValue = '';\\n  var negative = this.numberFormat.isNegative(str);\\n\\n  var checkIncompleteValue = function checkIncompleteValue(str) {\\n    if (str === '' && negative && previousConformedValue !== this$1.numberFormat.negativePrefix) {\\n      return '';\\n    } else if (this$1.numberFormat.maximumFractionDigits > 0) {\\n      if (this$1.numberFormat.isFractionIncomplete(str)) {\\n        return str;\\n      } else if (startsWith(str, this$1.numberFormat.decimalSymbol)) {\\n        return this$1.numberFormat.toFraction(str);\\n      }\\n    }\\n\\n    return null;\\n  };\\n\\n  var value = str;\\n  value = this.numberFormat.stripCurrencySymbol(value);\\n  value = this.numberFormat.stripMinusSymbol(value);\\n  var incompleteValue = checkIncompleteValue(value);\\n\\n  if (incompleteValue != null) {\\n    return this.numberFormat.insertCurrencySymbol(incompleteValue, negative);\\n  }\\n\\n  var ref = value.split(this.numberFormat.decimalSymbol);\\n  var integer = ref[0];\\n  var fraction = ref.slice(1);\\n  var integerDigits = removeLeadingZeros(this.numberFormat.onlyDigits(integer));\\n  var fractionDigits = this.numberFormat.onlyDigits(fraction.join('')).substr(0, this.numberFormat.maximumFractionDigits);\\n  var invalidFraction = fraction.length > 0 && fractionDigits.length === 0;\\n  var invalidNegativeValue = integerDigits === '' && negative && (previousConformedValue === str.slice(0, -1) || previousConformedValue !== this.numberFormat.negativePrefix);\\n\\n  if (invalidFraction || invalidNegativeValue) {\\n    return previousConformedValue;\\n  } else if (integerDigits.match(/\\\\d+/)) {\\n    return {\\n      numberValue: Number(\\\"\\\" + (negative ? '-' : '') + integerDigits + \\\".\\\" + fractionDigits),\\n      fractionDigits: fractionDigits\\n    };\\n  } else {\\n    return '';\\n  }\\n};\\n\\nvar AutoDecimalModeNumberMask = function AutoDecimalModeNumberMask(numberFormat) {\\n  this.numberFormat = numberFormat;\\n};\\n\\nAutoDecimalModeNumberMask.prototype.conformToMask = function conformToMask(str) {\\n  if (str === '') {\\n    return '';\\n  }\\n\\n  var negative = this.numberFormat.isNegative(str);\\n  var numberValue = this.numberFormat.stripMinusSymbol(str) === '' ? -0 : Number(\\\"\\\" + (negative ? '-' : '') + removeLeadingZeros(this.numberFormat.onlyDigits(str))) / Math.pow(10, this.numberFormat.minimumFractionDigits);\\n  return {\\n    numberValue: numberValue,\\n    fractionDigits: numberValue.toFixed(this.numberFormat.minimumFractionDigits).slice(-this.numberFormat.minimumFractionDigits)\\n  };\\n};\\n\\nvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\\n\\nvar init = function init(el, optionsFromBinding, ref) {\\n  var $ci = ref.$ci;\\n  var inputElement = el.tagName.toLowerCase() === 'input' ? el : el.querySelector('input');\\n\\n  if (!inputElement) {\\n    throw new Error('No input element found');\\n  }\\n\\n  var options = Object.assign({}, $ci ? $ci.GLOBAL_OPTIONS : DEFAULT_OPTIONS, optionsFromBinding);\\n  var distractionFree = options.distractionFree;\\n  var autoDecimalMode = options.autoDecimalMode;\\n  var valueRange = options.valueRange;\\n\\n  if (typeof distractionFree === 'boolean') {\\n    options.distractionFree = {\\n      hideCurrencySymbol: distractionFree,\\n      hideNegligibleDecimalDigits: distractionFree,\\n      hideGroupingSymbol: distractionFree\\n    };\\n  }\\n\\n  if (valueRange) {\\n    options.valueRange = {\\n      min: valueRange.min !== undefined ? Math.max(valueRange.min, -MAX_SAFE_INTEGER) : -MAX_SAFE_INTEGER,\\n      max: valueRange.max !== undefined ? Math.min(valueRange.max, MAX_SAFE_INTEGER) : MAX_SAFE_INTEGER\\n    };\\n  } else {\\n    options.valueRange = {\\n      min: -MAX_SAFE_INTEGER,\\n      max: MAX_SAFE_INTEGER\\n    };\\n  }\\n\\n  if (autoDecimalMode) {\\n    options.distractionFree.hideNegligibleDecimalDigits = false;\\n    inputElement.setAttribute('inputmode', 'numeric');\\n  } else {\\n    inputElement.setAttribute('inputmode', 'decimal');\\n  }\\n\\n  var currencyFormat = new NumberFormat(options);\\n  inputElement.$ci = Object.assign({}, inputElement.$ci || {\\n    numberValue: null\\n  }, {\\n    options: options,\\n    numberMask: options.autoDecimalMode ? new AutoDecimalModeNumberMask(currencyFormat) : new DefaultNumberMask(currencyFormat),\\n    currencyFormat: currencyFormat\\n  });\\n  return inputElement;\\n};\\n\\nvar triggerEvent = function triggerEvent(el, eventName) {\\n  var ref = el.$ci;\\n  var numberValue = ref.numberValue;\\n  var currencyFormat = ref.currencyFormat;\\n  var options = ref.options;\\n  numberValue = toExternalNumberModel(numberValue, options.valueAsInteger, currencyFormat.maximumFractionDigits);\\n  dispatchEvent$1(el, eventName, {\\n    numberValue: numberValue\\n  });\\n};\\n\\nvar applyFixedFractionFormat = function applyFixedFractionFormat(el, value, forcedChange) {\\n  if (forcedChange === void 0) forcedChange = false;\\n  var ref = el.$ci;\\n  var currencyFormat = ref.currencyFormat;\\n  var options = ref.options;\\n  var ref$1 = options.valueRange;\\n  var min = ref$1.min;\\n  var max = ref$1.max;\\n\\n  var validateValueRange = function validateValueRange() {\\n    return Math.min(Math.max(value, min), max);\\n  };\\n\\n  format(el, value != null ? currencyFormat.format(validateValueRange()) : null);\\n\\n  if (value !== el.$ci.numberValue || forcedChange) {\\n    triggerEvent(el, 'change');\\n  }\\n};\\n\\nvar updateInputValue = function updateInputValue(el, value, hideNegligibleDecimalDigits) {\\n  if (value != null) {\\n    var ref = el.$ci;\\n    var focus = ref.focus;\\n    var decimalSymbolInsertedAt = ref.decimalSymbolInsertedAt;\\n    var options = ref.options;\\n    var numberMask = ref.numberMask;\\n    var currencyFormat = ref.currencyFormat;\\n    var previousConformedValue = ref.previousConformedValue;\\n    var allowNegative = options.allowNegative;\\n    var distractionFree = options.distractionFree;\\n\\n    if (decimalSymbolInsertedAt !== undefined) {\\n      value = currencyFormat.normalizeDecimalSymbol(value, decimalSymbolInsertedAt);\\n      el.$ci.decimalSymbolInsertedAt = undefined;\\n    }\\n\\n    var conformedValue = numberMask.conformToMask(value, previousConformedValue);\\n    var formattedValue;\\n\\n    if (_typeof(conformedValue) === 'object') {\\n      var numberValue = conformedValue.numberValue;\\n      var fractionDigits = conformedValue.fractionDigits;\\n      var maximumFractionDigits = currencyFormat.maximumFractionDigits;\\n      var minimumFractionDigits = currencyFormat.minimumFractionDigits;\\n\\n      if (focus) {\\n        minimumFractionDigits = maximumFractionDigits;\\n      }\\n\\n      minimumFractionDigits = hideNegligibleDecimalDigits ? fractionDigits.replace(/0+$/, '').length : Math.min(minimumFractionDigits, fractionDigits.length);\\n      formattedValue = numberValue > MAX_SAFE_INTEGER ? previousConformedValue : currencyFormat.format(numberValue, {\\n        useGrouping: !(focus && distractionFree.hideGroupingSymbol),\\n        minimumFractionDigits: minimumFractionDigits,\\n        maximumFractionDigits: maximumFractionDigits\\n      });\\n    } else {\\n      formattedValue = conformedValue;\\n    }\\n\\n    if (!allowNegative) {\\n      formattedValue = formattedValue.replace(currencyFormat.negativePrefix, currencyFormat.prefix);\\n    }\\n\\n    if (focus && distractionFree.hideCurrencySymbol) {\\n      formattedValue = formattedValue.replace(currencyFormat.negativePrefix, currencyFormat.minusSymbol).replace(currencyFormat.prefix, '').replace(currencyFormat.suffix, '');\\n    }\\n\\n    el.value = formattedValue;\\n    el.$ci.numberValue = currencyFormat.parse(el.value);\\n  } else {\\n    el.value = el.$ci.numberValue = null;\\n  }\\n\\n  el.$ci.previousConformedValue = el.value;\\n};\\n\\nvar format = function format(el, value, hideNegligibleDecimalDigits) {\\n  if (hideNegligibleDecimalDigits === void 0) hideNegligibleDecimalDigits = false;\\n  updateInputValue(el, value, hideNegligibleDecimalDigits);\\n  triggerEvent(el, 'input');\\n};\\n\\nvar addEventListener = function addEventListener(el) {\\n  el.addEventListener('input', function (e) {\\n    if (!e.detail) {\\n      var value = el.value;\\n      var selectionStart = el.selectionStart;\\n      var el_$ci = el.$ci;\\n      var currencyFormat = el_$ci.currencyFormat;\\n      var options = el_$ci.options;\\n      format(el, value);\\n\\n      if (el.$ci.focus) {\\n        setCaretPosition(el, getCaretPositionAfterFormat(el.value, value, selectionStart, currencyFormat, options));\\n      }\\n    }\\n  }, {\\n    capture: true\\n  });\\n  el.addEventListener('keypress', function (e) {\\n    if (DECIMAL_SYMBOLS.includes(e.key)) {\\n      el.$ci.decimalSymbolInsertedAt = el.selectionStart;\\n    }\\n  });\\n  el.addEventListener('format', function (e) {\\n    var ref = el.$ci;\\n    var currencyFormat = ref.currencyFormat;\\n    var options = ref.options;\\n    var numberValue = ref.numberValue;\\n\\n    var toInternalNumberModel = function toInternalNumberModel(n) {\\n      return options.valueAsInteger && n != null ? n / Math.pow(10, currencyFormat.maximumFractionDigits) : n;\\n    };\\n\\n    var newValue = toInternalNumberModel(e.detail.value);\\n\\n    if (numberValue !== newValue) {\\n      applyFixedFractionFormat(el, newValue);\\n    }\\n  });\\n  el.addEventListener('focus', function () {\\n    el.$ci.focus = true;\\n    var ref = el.$ci.options.distractionFree;\\n    var hideCurrencySymbol = ref.hideCurrencySymbol;\\n    var hideGroupingSymbol = ref.hideGroupingSymbol;\\n    var hideNegligibleDecimalDigits = ref.hideNegligibleDecimalDigits;\\n\\n    if (hideCurrencySymbol || hideGroupingSymbol || hideNegligibleDecimalDigits) {\\n      setTimeout(function () {\\n        var value = el.value;\\n        var selectionStart = el.selectionStart;\\n        var selectionEnd = el.selectionEnd;\\n\\n        if (value) {\\n          format(el, value, hideNegligibleDecimalDigits);\\n        }\\n\\n        if (Math.abs(selectionStart - selectionEnd) > 0) {\\n          el.setSelectionRange(0, el.value.length);\\n        } else {\\n          setCaretPosition(el, getDistractionFreeCaretPosition(el.$ci.currencyFormat, el.$ci.options, value, selectionStart));\\n        }\\n      });\\n    }\\n  });\\n  el.addEventListener('blur', function () {\\n    el.$ci.focus = false;\\n\\n    if (el.$ci.numberValue != null) {\\n      applyFixedFractionFormat(el, el.$ci.numberValue);\\n    }\\n  });\\n  el.addEventListener('change', function (e) {\\n    if (!e.detail) {\\n      triggerEvent(el, 'change');\\n    }\\n  });\\n};\\n\\nvar directive = {\\n  bind: function bind(el, ref, ref$1) {\\n    var value = ref.value;\\n    var context = ref$1.context;\\n    var inputElement = init(el, value, context);\\n    addEventListener(inputElement);\\n    setValue$1(inputElement, inputElement.$ci.currencyFormat.parse(inputElement.value));\\n  },\\n  componentUpdated: function componentUpdated(el, ref, ref$1) {\\n    var value = ref.value;\\n    var oldValue = ref.oldValue;\\n    var context = ref$1.context;\\n\\n    if (!equal(value, oldValue)) {\\n      var inputElement = init(el, value, context);\\n      applyFixedFractionFormat(inputElement, inputElement.$ci.numberValue, true);\\n    }\\n  }\\n};\\nvar component = {\\n  render: function render(h) {\\n    var this$1 = this;\\n    return h('input', {\\n      directives: [{\\n        name: 'currency',\\n        value: this.options\\n      }],\\n      on: Object.assign({}, this.$listeners, {\\n        change: function change(e) {\\n          if (e.detail) {\\n            this$1.$emit('change', e.detail.numberValue);\\n          }\\n        },\\n        input: function input(e) {\\n          if (e.detail && this$1.value !== e.detail.numberValue) {\\n            this$1.$emit('input', e.detail.numberValue);\\n          }\\n        }\\n      })\\n    });\\n  },\\n  directives: {\\n    currency: directive\\n  },\\n  name: 'CurrencyInput',\\n  props: {\\n    value: {\\n      type: Number,\\n      default: null\\n    },\\n    locale: {\\n      type: String,\\n      default: undefined\\n    },\\n    currency: {\\n      type: [String, Object],\\n      default: undefined\\n    },\\n    distractionFree: {\\n      type: [Boolean, Object],\\n      default: undefined\\n    },\\n    precision: {\\n      type: [Number, Object],\\n      default: undefined\\n    },\\n    autoDecimalMode: {\\n      type: Boolean,\\n      default: undefined\\n    },\\n    valueAsInteger: {\\n      type: Boolean,\\n      default: undefined\\n    },\\n    valueRange: {\\n      type: Object,\\n      default: undefined\\n    },\\n    allowNegative: {\\n      type: Boolean,\\n      default: undefined\\n    }\\n  },\\n  mounted: function mounted() {\\n    this.setValue(this.value);\\n  },\\n  computed: {\\n    options: function options() {\\n      var this$1 = this;\\n      var options = Object.assign({}, this.$ci ? this.$ci.GLOBAL_OPTIONS : DEFAULT_OPTIONS);\\n      Object.keys(DEFAULT_OPTIONS).forEach(function (key) {\\n        if (this$1[key] !== undefined) {\\n          options[key] = this$1[key];\\n        }\\n      });\\n      return options;\\n    }\\n  },\\n  watch: {\\n    value: 'setValue'\\n  },\\n  methods: {\\n    setValue: function setValue$1$1(value) {\\n      setValue$1(this.$el, value);\\n    }\\n  }\\n};\\nvar plugin = {\\n  install: function install(Vue, ref) {\\n    if (ref === void 0) ref = {};\\n    var componentName = ref.componentName;\\n    if (componentName === void 0) componentName = component.name;\\n    var directiveName = ref.directiveName;\\n    if (directiveName === void 0) directiveName = 'currency';\\n    var globalOptions = ref.globalOptions;\\n    if (globalOptions === void 0) globalOptions = {};\\n    Vue.component(componentName, component);\\n    Vue.directive(directiveName, directive);\\n    Vue.prototype.$ci = {\\n      getValue: getValue,\\n      setValue: setValue$1,\\n      GLOBAL_OPTIONS: Object.assign({}, DEFAULT_OPTIONS, globalOptions)\\n    };\\n  }\\n};\\n\\nif (typeof window !== 'undefined' && window.Vue) {\\n  window.Vue.use(plugin);\\n}\\n\\nvar options = {\\n  locale: undefined,\\n  currency: undefined,\\n  decimalLength: 2,\\n  autoDecimalMode: true,\\n  min: null,\\n  max: null,\\n  defaultValue: 0,\\n  valueAsInteger: false,\\n  allowNegative: true\\n};\\n\\nvar script = {\\n  name: 'VCurrencyField',\\n  props: {\\n    value: {\\n      type: [Number, String],\\n      default: function _default() {\\n        return 0;\\n      }\\n    },\\n    locale: {\\n      type: String,\\n      default: function _default() {\\n        return options.locale;\\n      }\\n    },\\n    currency: {\\n      type: [String, Object],\\n      default: function _default() {\\n        return options.currency;\\n      }\\n    },\\n    decimalLength: {\\n      type: [Number, Object],\\n      default: function _default() {\\n        return options.decimalLength;\\n      }\\n    },\\n    autoDecimalMode: {\\n      type: Boolean,\\n      default: function _default() {\\n        return options.autoDecimalMode;\\n      }\\n    },\\n    min: {\\n      type: Number,\\n      default: function _default() {\\n        return options.min;\\n      }\\n    },\\n    max: {\\n      type: Number,\\n      default: function _default() {\\n        return options.max;\\n      }\\n    },\\n    defaultValue: {\\n      type: Number,\\n      default: function _default() {\\n        return options.defaultValue;\\n      }\\n    },\\n    valueAsInteger: {\\n      type: Boolean,\\n      default: function _default() {\\n        return options.valueAsInteger;\\n      }\\n    },\\n    allowNegative: {\\n      type: Boolean,\\n      default: function _default() {\\n        return options.allowNegative;\\n      }\\n    }\\n  },\\n  directives: {\\n    CurrencyDirective: directive\\n  },\\n  data: function data() {\\n    return {\\n      formattedValue: this.value\\n    };\\n  },\\n  mounted: function mounted() {\\n    this.addListeners(this.$el.querySelector('input'));\\n  },\\n  computed: {\\n    attrs: function attrs() {\\n      // eslint-disable-next-line\\n      var _this$$attrs = this.$attrs,\\n          value = _this$$attrs.value,\\n          attrs = _objectWithoutProperties(_this$$attrs, [\\\"value\\\"]); // all but input event\\n\\n\\n      return attrs;\\n    },\\n    distractionFree: function distractionFree() {\\n      if (this.decimalLength > 0) {\\n        return !this.autoDecimalMode;\\n      } else {\\n        return false;\\n      }\\n    },\\n    decimalMode: function decimalMode() {\\n      if (this.decimalLength > 0) {\\n        return this.autoDecimalMode;\\n      } else {\\n        return false;\\n      }\\n    },\\n    valueRange: function valueRange() {\\n      if (this.min || this.max) {\\n        return {\\n          min: this.min,\\n          max: this.max\\n        };\\n      } else {\\n        return undefined;\\n      }\\n    }\\n  },\\n  watch: {\\n    value: 'setValue'\\n  },\\n  methods: {\\n    addListeners: function addListeners(el) {\\n      var _this = this;\\n\\n      el.addEventListener('change', function (e) {\\n        if (e.detail) {\\n          _this.$emit('change', e.detail.numberValue);\\n        }\\n\\n        if (_this.value == null && _this.value == undefined && _this.defaultValue !== null && _this.defaultValue !== undefined) {\\n          _this.setValue(_this.valueAsInteger && _this.defaultValue ? _this.defaultValue * Math.pow(10, _this.decimalLength) : _this.defaultValue);\\n        }\\n      }, {\\n        capture: true\\n      });\\n      el.addEventListener('input', function (e) {\\n        if (e.detail && _this.value !== e.detail.numberValue) {\\n          _this.$emit('input', e.detail.numberValue);\\n        }\\n      }, {\\n        capture: true\\n      });\\n    },\\n    setValue: function setValue$1(value) {\\n      var input = this.$el.querySelector('input');\\n\\n      setValue(input, value);\\n    },\\n    listeners: function listeners() {\\n      var _this2 = this;\\n\\n      // eslint-disable-next-line\\n      var _this$$listeners = this.$listeners,\\n          input = _this$$listeners.input,\\n          _keyup = _this$$listeners.keyup,\\n          listeners = _objectWithoutProperties(_this$$listeners, [\\\"input\\\", \\\"keyup\\\"]); // all but input event\\n\\n\\n      return _objectSpread2(_objectSpread2({}, listeners), {}, {\\n        input: function input(value) {\\n          if (_this2.$refs.textfield.isResetting || value == null) {\\n            _this2.setValue(_this2.valueAsInteger && _this2.defaultValue ? _this2.defaultValue * Math.pow(10, _this2.decimalLength) : _this2.defaultValue);\\n          }\\n        },\\n        'keyup': function keyup(event) {\\n          if (event.key === '-' || event.key === '+') {\\n            if (_this2.value != null && event.key === '-' && _this2.value >= 0) {\\n              _this2.setValue(_this2.value * -1);\\n            }\\n\\n            if (_this2.value != null && event.key === '+' && _this2.value <= 0) {\\n              _this2.setValue(_this2.value * -1);\\n            }\\n          }\\n\\n          if (_keyup) {\\n            _keyup();\\n          }\\n        }\\n      });\\n    }\\n  }\\n};\\n\\nfunction normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier\\n/* server only */\\n, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\\n  if (typeof shadowMode !== 'boolean') {\\n    createInjectorSSR = createInjector;\\n    createInjector = shadowMode;\\n    shadowMode = false;\\n  } // Vue.extend constructor export interop.\\n\\n\\n  var options = typeof script === 'function' ? script.options : script; // render functions\\n\\n  if (template && template.render) {\\n    options.render = template.render;\\n    options.staticRenderFns = template.staticRenderFns;\\n    options._compiled = true; // functional template\\n\\n    if (isFunctionalTemplate) {\\n      options.functional = true;\\n    }\\n  } // scopedId\\n\\n\\n  if (scopeId) {\\n    options._scopeId = scopeId;\\n  }\\n\\n  var hook;\\n\\n  if (moduleIdentifier) {\\n    // server build\\n    hook = function hook(context) {\\n      // 2.3 injection\\n      context = context || // cached call\\n      this.$vnode && this.$vnode.ssrContext || // stateful\\n      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional\\n      // 2.2 with runInNewContext: true\\n\\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\\n        context = __VUE_SSR_CONTEXT__;\\n      } // inject component styles\\n\\n\\n      if (style) {\\n        style.call(this, createInjectorSSR(context));\\n      } // register component module identifier for async chunk inference\\n\\n\\n      if (context && context._registeredComponents) {\\n        context._registeredComponents.add(moduleIdentifier);\\n      }\\n    }; // used by ssr in case component is cached and beforeCreate\\n    // never gets called\\n\\n\\n    options._ssrRegister = hook;\\n  } else if (style) {\\n    hook = shadowMode ? function () {\\n      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));\\n    } : function (context) {\\n      style.call(this, createInjector(context));\\n    };\\n  }\\n\\n  if (hook) {\\n    if (options.functional) {\\n      // register for functional component in vue file\\n      var originalRender = options.render;\\n\\n      options.render = function renderWithStyleInjection(h, context) {\\n        hook.call(context);\\n        return originalRender(h, context);\\n      };\\n    } else {\\n      // inject component registration as beforeCreate hook\\n      var existing = options.beforeCreate;\\n      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\\n    }\\n  }\\n\\n  return script;\\n}\\n\\nvar normalizeComponent_1 = normalizeComponent;\\n\\n/* script */\\nconst __vue_script__ = script;\\n\\n/* template */\\nvar __vue_render__ = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('v-text-field',_vm._g(_vm._b({directives:[{name:\\\"currency-directive\\\",rawName:\\\"v-currency-directive\\\",value:({currency: _vm.currency, locale: _vm.locale, distractionFree: _vm.distractionFree, precision: _vm.decimalLength, autoDecimalMode: _vm.decimalMode, valueRange: _vm.valueRange, allowNegative: _vm.allowNegative, valueAsInteger: _vm.valueAsInteger}),expression:\\\"{currency, locale, distractionFree, precision: decimalLength, autoDecimalMode: decimalMode, valueRange, allowNegative, valueAsInteger}\\\"}],ref:\\\"textfield\\\",attrs:{\\\"type\\\":\\\"text\\\"},scopedSlots:_vm._u([_vm._l((_vm.$slots),function(index,name){return {key:name,fn:function(){return [_vm._t(name)]},proxy:true}})],null,true),model:{value:(_vm.formattedValue),callback:function ($$v) {_vm.formattedValue=$$v;},expression:\\\"formattedValue\\\"}},'v-text-field',_vm.attrs,false),_vm.listeners()))};\\nvar __vue_staticRenderFns__ = [];\\n\\n  /* style */\\n  const __vue_inject_styles__ = undefined;\\n  /* scoped */\\n  const __vue_scope_id__ = undefined;\\n  /* module identifier */\\n  const __vue_module_identifier__ = undefined;\\n  /* functional template */\\n  const __vue_is_functional_template__ = false;\\n  /* style inject */\\n  \\n  /* style inject SSR */\\n  \\n\\n  \\n  var VCurrencyField = normalizeComponent_1(\\n    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },\\n    __vue_inject_styles__,\\n    __vue_script__,\\n    __vue_scope_id__,\\n    __vue_is_functional_template__,\\n    __vue_module_identifier__,\\n    undefined,\\n    undefined\\n  );\\n\\nvar version = '3.1.1';\\n\\nfunction install(Vue, globalOptions) {\\n  if (globalOptions) {\\n    Object.keys(globalOptions).map(function (key) {\\n      options[key] = globalOptions[key];\\n    });\\n  }\\n\\n  Vue.component('v-currency-field', VCurrencyField);\\n}\\n\\nif (typeof window !== 'undefined' && window.Vue) {\\n  window.Vue.use(install);\\n}\\n\\n/* harmony default export */ __webpack_exports__[\\\"default\\\"] = (install);\\n\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdi1jdXJyZW5jeS1maWVsZC9kaXN0L3YtY3VycmVuY3ktZmllbGQuZXNtLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3YtY3VycmVuY3ktZmllbGQvZGlzdC92LWN1cnJlbmN5LWZpZWxkLmVzbS5qcz9hNTYzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogdi1jdXJyZW5jeS1maWVsZCB2My4xLjEgXG4gKiAoYykgMjAyMCBQaGlsaXBlIEF1Z3VzdG8gPHBoaW55MUBnbWFpbC5jb20+XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG5cbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuXG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBkaXNwYXRjaEV2ZW50ID0gKGZ1bmN0aW9uIChlbCwgZXZlbnROYW1lLCBkYXRhKSB7XG4gIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICBldmVudC5pbml0Q3VzdG9tRXZlbnQoZXZlbnROYW1lLCB0cnVlLCB0cnVlLCBkYXRhKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG59KTtcblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiBhbiBpbnB1dCBwcm9ncmFtbWF0aWNhbGx5LlxuICpcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gZWwgVGhlIGlucHV0IGVsZW1lbnQgdGhlIGB2LWN1cnJlbmN5YCBkaXJlY3RpdmUgaXMgYm91bmQgdG8uXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIG51bWJlciB0byBiZSBzZXQuXG4gKi9cblxudmFyIHNldFZhbHVlID0gZnVuY3Rpb24gc2V0VmFsdWUoZWwsIHZhbHVlKSB7XG4gIHJldHVybiBkaXNwYXRjaEV2ZW50KGVsLCAnZm9ybWF0Jywge1xuICAgIHZhbHVlOiB2YWx1ZVxuICB9KTtcbn07XG5cbi8qKlxuICogVnVlIEN1cnJlbmN5IElucHV0IDEuMjEuMFxuICogKGMpIDIwMTgtMjAyMCBNYXR0aGlhcyBTdGlsbGVyXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCQxKGVsLCBldmVudE5hbWUsIGRhdGEpIHtcbiAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gIGV2ZW50LmluaXRDdXN0b21FdmVudChldmVudE5hbWUsIHRydWUsIHRydWUsIGRhdGEpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn1cblxudmFyIHRvRXh0ZXJuYWxOdW1iZXJNb2RlbCA9IGZ1bmN0aW9uIHRvRXh0ZXJuYWxOdW1iZXJNb2RlbChudW1iZXIsIHZhbHVlQXNJbnRlZ2VyLCBmcmFjdGlvbkRpZ2l0cykge1xuICByZXR1cm4gdmFsdWVBc0ludGVnZXIgJiYgbnVtYmVyICE9IG51bGwgPyBOdW1iZXIobnVtYmVyLnRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpLnNwbGl0KCcuJykuam9pbignJykpIDogbnVtYmVyO1xufTtcblxudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgbG9jYWxlOiB1bmRlZmluZWQsXG4gIGN1cnJlbmN5OiAnRVVSJyxcbiAgdmFsdWVBc0ludGVnZXI6IGZhbHNlLFxuICBkaXN0cmFjdGlvbkZyZWU6IHRydWUsXG4gIHByZWNpc2lvbjogdW5kZWZpbmVkLFxuICBhdXRvRGVjaW1hbE1vZGU6IGZhbHNlLFxuICB2YWx1ZVJhbmdlOiB1bmRlZmluZWQsXG4gIGFsbG93TmVnYXRpdmU6IHRydWVcbn07XG5cbnZhciBnZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKGVsKSB7XG4gIHZhciByZWYgPSBlbC4kY2k7XG4gIHZhciBudW1iZXJWYWx1ZSA9IHJlZi5udW1iZXJWYWx1ZTtcbiAgdmFyIGN1cnJlbmN5Rm9ybWF0ID0gcmVmLmN1cnJlbmN5Rm9ybWF0O1xuICB2YXIgb3B0aW9ucyA9IHJlZi5vcHRpb25zO1xuICByZXR1cm4gdG9FeHRlcm5hbE51bWJlck1vZGVsKG51bWJlclZhbHVlLCBvcHRpb25zLnZhbHVlQXNJbnRlZ2VyLCBjdXJyZW5jeUZvcm1hdC5tYXhpbXVtRnJhY3Rpb25EaWdpdHMpO1xufTtcblxudmFyIHNldFZhbHVlJDEgPSBmdW5jdGlvbiBzZXRWYWx1ZShlbCwgdmFsdWUpIHtcbiAgcmV0dXJuIGRpc3BhdGNoRXZlbnQkMShlbCwgJ2Zvcm1hdCcsIHtcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSk7XG59O1xuXG52YXIgZXNjYXBlUmVnRXhwID0gZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG59O1xuXG52YXIgcmVtb3ZlTGVhZGluZ1plcm9zID0gZnVuY3Rpb24gcmVtb3ZlTGVhZGluZ1plcm9zKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL14wKygwJHxbXjBdKS8sICckMScpO1xufTtcblxudmFyIGNvdW50ID0gZnVuY3Rpb24gY291bnQoc3RyLCBzZWFyY2gpIHtcbiAgcmV0dXJuIChzdHIubWF0Y2gobmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAoc2VhcmNoKSwgJ2cnKSkgfHwgW10pLmxlbmd0aDtcbn07XG5cbnZhciBzdGFydHNXaXRoID0gZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHNlYXJjaCkge1xuICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xufTtcblxudmFyIHN1YnN0cmluZ0JlZm9yZSA9IGZ1bmN0aW9uIHN1YnN0cmluZ0JlZm9yZShzdHIsIHNlYXJjaCkge1xuICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCBzdHIuaW5kZXhPZihzZWFyY2gpKTtcbn07XG5cbnZhciBzZXRDYXJldFBvc2l0aW9uID0gZnVuY3Rpb24gc2V0Q2FyZXRQb3NpdGlvbihlbCwgcG9zaXRpb24pIHtcbiAgcmV0dXJuIGVsLnNldFNlbGVjdGlvblJhbmdlKHBvc2l0aW9uLCBwb3NpdGlvbik7XG59O1xuXG52YXIgZ2V0Q2FyZXRQb3NpdGlvbkFmdGVyRm9ybWF0ID0gZnVuY3Rpb24gZ2V0Q2FyZXRQb3NpdGlvbkFmdGVyRm9ybWF0KG5ld1ZhbHVlLCBpbnB1dHRlZFZhbHVlLCBjYXJldFBvc2l0aW9uLCBudW1iZXJGb3JtYXQsIG9wdGlvbnMpIHtcbiAgdmFyIHByZWZpeCA9IG51bWJlckZvcm1hdC5wcmVmaXg7XG4gIHZhciBzdWZmaXggPSBudW1iZXJGb3JtYXQuc3VmZml4O1xuICB2YXIgZGVjaW1hbFN5bWJvbCA9IG51bWJlckZvcm1hdC5kZWNpbWFsU3ltYm9sO1xuICB2YXIgbWF4aW11bUZyYWN0aW9uRGlnaXRzID0gbnVtYmVyRm9ybWF0Lm1heGltdW1GcmFjdGlvbkRpZ2l0cztcbiAgdmFyIGdyb3VwaW5nU3ltYm9sID0gbnVtYmVyRm9ybWF0Lmdyb3VwaW5nU3ltYm9sO1xuICB2YXIgZGVjaW1hbFN5bWJvbFBvc2l0aW9uID0gaW5wdXR0ZWRWYWx1ZS5pbmRleE9mKGRlY2ltYWxTeW1ib2wpICsgMTtcbiAgdmFyIGNhcmV0UG9zaXRpb25Gcm9tTGVmdCA9IGlucHV0dGVkVmFsdWUubGVuZ3RoIC0gY2FyZXRQb3NpdGlvbjtcblxuICBpZiAoTWF0aC5hYnMobmV3VmFsdWUubGVuZ3RoIC0gaW5wdXR0ZWRWYWx1ZS5sZW5ndGgpID4gMSAmJiBjYXJldFBvc2l0aW9uIDw9IGRlY2ltYWxTeW1ib2xQb3NpdGlvbikge1xuICAgIHJldHVybiBuZXdWYWx1ZS5pbmRleE9mKGRlY2ltYWxTeW1ib2wpICsgMTtcbiAgfSBlbHNlIGlmIChuZXdWYWx1ZS5zdWJzdHIoY2FyZXRQb3NpdGlvbiwgMSkgPT09IGdyb3VwaW5nU3ltYm9sICYmIGNvdW50KG5ld1ZhbHVlLCBncm91cGluZ1N5bWJvbCkgPT09IGNvdW50KGlucHV0dGVkVmFsdWUsIGdyb3VwaW5nU3ltYm9sKSArIDEpIHtcbiAgICByZXR1cm4gbmV3VmFsdWUubGVuZ3RoIC0gY2FyZXRQb3NpdGlvbkZyb21MZWZ0IC0gMTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIW9wdGlvbnMuYXV0b0RlY2ltYWxNb2RlICYmIGRlY2ltYWxTeW1ib2xQb3NpdGlvbiAhPT0gMCAmJiBjYXJldFBvc2l0aW9uID4gZGVjaW1hbFN5bWJvbFBvc2l0aW9uKSB7XG4gICAgICBpZiAobnVtYmVyRm9ybWF0Lm9ubHlEaWdpdHMoaW5wdXR0ZWRWYWx1ZS5zdWJzdHIoZGVjaW1hbFN5bWJvbFBvc2l0aW9uKSkubGVuZ3RoIC0gMSA9PT0gbWF4aW11bUZyYWN0aW9uRGlnaXRzKSB7XG4gICAgICAgIGNhcmV0UG9zaXRpb25Gcm9tTGVmdCAtPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zLmRpc3RyYWN0aW9uRnJlZS5oaWRlQ3VycmVuY3lTeW1ib2wgPyBuZXdWYWx1ZS5sZW5ndGggLSBjYXJldFBvc2l0aW9uRnJvbUxlZnQgOiBNYXRoLm1heChuZXdWYWx1ZS5sZW5ndGggLSBNYXRoLm1heChjYXJldFBvc2l0aW9uRnJvbUxlZnQsIHN1ZmZpeC5sZW5ndGgpLCBwcmVmaXgubGVuZ3RoID09PSAwID8gMCA6IHByZWZpeC5sZW5ndGggKyAxKTtcbiAgfVxufTtcblxudmFyIGdldERpc3RyYWN0aW9uRnJlZUNhcmV0UG9zaXRpb24gPSBmdW5jdGlvbiBnZXREaXN0cmFjdGlvbkZyZWVDYXJldFBvc2l0aW9uKG51bWJlckZvcm1hdCwgb3B0aW9ucywgdmFsdWUsIGNhcmV0UG9zaXRpb24pIHtcbiAgdmFyIHJlc3VsdCA9IGNhcmV0UG9zaXRpb247XG5cbiAgaWYgKG9wdGlvbnMuZGlzdHJhY3Rpb25GcmVlLmhpZGVDdXJyZW5jeVN5bWJvbCkge1xuICAgIHJlc3VsdCAtPSBudW1iZXJGb3JtYXQucHJlZml4Lmxlbmd0aDtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmRpc3RyYWN0aW9uRnJlZS5oaWRlR3JvdXBpbmdTeW1ib2wpIHtcbiAgICByZXN1bHQgLT0gY291bnQodmFsdWUuc3Vic3RyaW5nKDAsIGNhcmV0UG9zaXRpb24pLCBudW1iZXJGb3JtYXQuZ3JvdXBpbmdTeW1ib2wpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4KDAsIHJlc3VsdCk7XG59O1xuXG52YXIgZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIWEgfHwgIWIgfHwgX3R5cGVvZihhKSAhPT0gJ29iamVjdCcgfHwgX3R5cGVvZihiKSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuXG4gIGlmIChrZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFrZXlzLmV2ZXJ5KE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuYmluZChiKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4ga2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGVxdWFsKGFba2V5XSwgYltrZXldKTtcbiAgfSk7XG59O1xuXG52YXIgREVDSU1BTF9TWU1CT0xTID0gWycsJywgJy4nLCAn2asnXTtcblxudmFyIE51bWJlckZvcm1hdCA9IGZ1bmN0aW9uIE51bWJlckZvcm1hdChvcHRpb25zKSB7XG4gIHZhciBjdXJyZW5jeSA9IG9wdGlvbnMuY3VycmVuY3k7XG4gIHZhciBsb2NhbGUgPSBvcHRpb25zLmxvY2FsZTtcbiAgdmFyIHByZWNpc2lvbiA9IG9wdGlvbnMucHJlY2lzaW9uO1xuICB2YXIgYXV0b0RlY2ltYWxNb2RlID0gb3B0aW9ucy5hdXRvRGVjaW1hbE1vZGU7XG4gIHZhciB2YWx1ZUFzSW50ZWdlciA9IG9wdGlvbnMudmFsdWVBc0ludGVnZXI7XG4gIHZhciBudW1iZXJGb3JtYXQgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCB0eXBlb2YgY3VycmVuY3kgPT09ICdzdHJpbmcnID8ge1xuICAgIGN1cnJlbmN5OiBjdXJyZW5jeSxcbiAgICBzdHlsZTogJ2N1cnJlbmN5J1xuICB9IDoge1xuICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMVxuICB9KTtcbiAgdmFyIHBzID0gbnVtYmVyRm9ybWF0LmZvcm1hdCgxMjM0NTYpO1xuICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgdGhpcy5jdXJyZW5jeSA9IGN1cnJlbmN5O1xuICB0aGlzLmRpZ2l0cyA9IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gaS50b0xvY2FsZVN0cmluZyhsb2NhbGUpO1xuICB9KTtcbiAgdGhpcy5kZWNpbWFsU3ltYm9sID0gY291bnQocHMsIHRoaXMuZGlnaXRzWzBdKSA/IHBzLnN1YnN0cihwcy5pbmRleE9mKHRoaXMuZGlnaXRzWzZdKSArIDEsIDEpIDogdW5kZWZpbmVkO1xuICB0aGlzLmdyb3VwaW5nU3ltYm9sID0gcHMuc3Vic3RyKHBzLmluZGV4T2YodGhpcy5kaWdpdHNbM10pICsgMSwgMSk7XG4gIHRoaXMubWludXNTeW1ib2wgPSBzdWJzdHJpbmdCZWZvcmUoTnVtYmVyKC0xKS50b0xvY2FsZVN0cmluZyhsb2NhbGUpLCB0aGlzLmRpZ2l0c1sxXSk7XG5cbiAgaWYgKHRoaXMuZGVjaW1hbFN5bWJvbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5taW5pbXVtRnJhY3Rpb25EaWdpdHMgPSB0aGlzLm1heGltdW1GcmFjdGlvbkRpZ2l0cyA9IDA7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByZWNpc2lvbiA9PT0gJ251bWJlcicpIHtcbiAgICB0aGlzLm1pbmltdW1GcmFjdGlvbkRpZ2l0cyA9IHRoaXMubWF4aW11bUZyYWN0aW9uRGlnaXRzID0gcHJlY2lzaW9uO1xuICB9IGVsc2UgaWYgKF90eXBlb2YocHJlY2lzaW9uKSA9PT0gJ29iamVjdCcgJiYgIWF1dG9EZWNpbWFsTW9kZSAmJiAhdmFsdWVBc0ludGVnZXIpIHtcbiAgICB0aGlzLm1pbmltdW1GcmFjdGlvbkRpZ2l0cyA9IHByZWNpc2lvbi5taW4gfHwgMDtcbiAgICB0aGlzLm1heGltdW1GcmFjdGlvbkRpZ2l0cyA9IHByZWNpc2lvbi5tYXggIT09IHVuZGVmaW5lZCA/IHByZWNpc2lvbi5tYXggOiAyMDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY3VycmVuY3kgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5taW5pbXVtRnJhY3Rpb25EaWdpdHMgPSBudW1iZXJGb3JtYXQucmVzb2x2ZWRPcHRpb25zKCkubWluaW11bUZyYWN0aW9uRGlnaXRzO1xuICAgIHRoaXMubWF4aW11bUZyYWN0aW9uRGlnaXRzID0gbnVtYmVyRm9ybWF0LnJlc29sdmVkT3B0aW9ucygpLm1heGltdW1GcmFjdGlvbkRpZ2l0cztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm1pbmltdW1GcmFjdGlvbkRpZ2l0cyA9IHRoaXMubWF4aW11bUZyYWN0aW9uRGlnaXRzID0gMjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY3VycmVuY3kgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5wcmVmaXggPSBzdWJzdHJpbmdCZWZvcmUocHMsIHRoaXMuZGlnaXRzWzFdKTtcbiAgICB0aGlzLm5lZ2F0aXZlUHJlZml4ID0gc3Vic3RyaW5nQmVmb3JlKG51bWJlckZvcm1hdC5mb3JtYXQoLTEpLCB0aGlzLmRpZ2l0c1sxXSk7XG4gICAgdGhpcy5zdWZmaXggPSBwcy5zdWJzdHJpbmcocHMubGFzdEluZGV4T2YodGhpcy5kZWNpbWFsU3ltYm9sID8gdGhpcy5kaWdpdHNbMF0gOiB0aGlzLmRpZ2l0c1s2XSkgKyAxKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnByZWZpeCA9IChjdXJyZW5jeSB8fCB7fSkucHJlZml4IHx8ICcnO1xuICAgIHRoaXMubmVnYXRpdmVQcmVmaXggPSBcIlwiICsgdGhpcy5taW51c1N5bWJvbCArIHRoaXMucHJlZml4O1xuICAgIHRoaXMuc3VmZml4ID0gKGN1cnJlbmN5IHx8IHt9KS5zdWZmaXggfHwgJyc7XG4gIH1cbn07XG5cbk51bWJlckZvcm1hdC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgdmFyIG5lZ2F0aXZlID0gdGhpcy5pc05lZ2F0aXZlKHN0cik7XG4gIHN0ciA9IHRoaXMubm9ybWFsaXplRGlnaXRzKHN0cik7XG4gIHN0ciA9IHRoaXMuc3RyaXBDdXJyZW5jeVN5bWJvbChzdHIpO1xuICBzdHIgPSB0aGlzLnN0cmlwTWludXNTeW1ib2woc3RyKTtcbiAgdmFyIGZyYWN0aW9uID0gdGhpcy5kZWNpbWFsU3ltYm9sID8gXCIoXCIgKyBlc2NhcGVSZWdFeHAodGhpcy5kZWNpbWFsU3ltYm9sKSArIFwiXFxcXGQqKT9cIiA6ICcnO1xuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2gobmV3IFJlZ0V4cChcIl5cIiArIHRoaXMuaW50ZWdlclBhdHRlcm4oKSArIGZyYWN0aW9uICsgXCIkXCIpKTtcblxuICBpZiAobWF0Y2gpIHtcbiAgICByZXR1cm4gTnVtYmVyKFwiXCIgKyAobmVnYXRpdmUgPyAnLScgOiAnJykgKyB0aGlzLm9ubHlEaWdpdHMobWF0Y2hbMV0pICsgXCIuXCIgKyB0aGlzLm9ubHlEaWdpdHMobWF0Y2hbM10gfHwgJycpKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuTnVtYmVyRm9ybWF0LnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQobnVtYmVyLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7XG4gICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiB0aGlzLm1pbmltdW1GcmFjdGlvbkRpZ2l0cyxcbiAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IHRoaXMubWF4aW11bUZyYWN0aW9uRGlnaXRzXG4gIH07XG5cbiAgaWYgKHR5cGVvZiB0aGlzLmN1cnJlbmN5ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBudW1iZXIudG9Mb2NhbGVTdHJpbmcodGhpcy5sb2NhbGUsIE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgIHN0eWxlOiAnY3VycmVuY3knLFxuICAgICAgY3VycmVuY3k6IHRoaXMuY3VycmVuY3lcbiAgICB9LCBvcHRpb25zKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0Q3VycmVuY3lTeW1ib2woTWF0aC5hYnMobnVtYmVyKS50b0xvY2FsZVN0cmluZyh0aGlzLmxvY2FsZSwgb3B0aW9ucyksIG51bWJlciA8IDAgfHwgbnVtYmVyID09PSAwICYmIDEgLyBudW1iZXIgPCAwKTtcbiAgfVxufTtcblxuTnVtYmVyRm9ybWF0LnByb3RvdHlwZS5pbnRlZ2VyUGF0dGVybiA9IGZ1bmN0aW9uIGludGVnZXJQYXR0ZXJuKCkge1xuICByZXR1cm4gXCIoMHxbMS05XVxcXFxkezAsMn0oXCIgKyBlc2NhcGVSZWdFeHAodGhpcy5ncm91cGluZ1N5bWJvbCkgKyBcIj9cXFxcZHszfSkqKVwiO1xufTtcblxuTnVtYmVyRm9ybWF0LnByb3RvdHlwZS50b0ZyYWN0aW9uID0gZnVuY3Rpb24gdG9GcmFjdGlvbihzdHIpIHtcbiAgcmV0dXJuIFwiXCIgKyB0aGlzLmRpZ2l0c1swXSArIHRoaXMuZGVjaW1hbFN5bWJvbCArIHRoaXMub25seUxvY2FsZURpZ2l0cyhzdHIuc3Vic3RyKDEpKS5zdWJzdHIoMCwgdGhpcy5tYXhpbXVtRnJhY3Rpb25EaWdpdHMpO1xufTtcblxuTnVtYmVyRm9ybWF0LnByb3RvdHlwZS5pc0ZyYWN0aW9uSW5jb21wbGV0ZSA9IGZ1bmN0aW9uIGlzRnJhY3Rpb25JbmNvbXBsZXRlKHN0cikge1xuICByZXR1cm4gISF0aGlzLm5vcm1hbGl6ZURpZ2l0cyhzdHIpLm1hdGNoKG5ldyBSZWdFeHAoXCJeXCIgKyB0aGlzLmludGVnZXJQYXR0ZXJuKCkgKyBlc2NhcGVSZWdFeHAodGhpcy5kZWNpbWFsU3ltYm9sKSArIFwiJFwiKSk7XG59O1xuXG5OdW1iZXJGb3JtYXQucHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiBpc05lZ2F0aXZlKHN0cikge1xuICByZXR1cm4gc3RhcnRzV2l0aChzdHIsIHRoaXMubmVnYXRpdmVQcmVmaXgpIHx8IHN0YXJ0c1dpdGgoc3RyLnJlcGxhY2UoJy0nLCB0aGlzLm1pbnVzU3ltYm9sKSwgdGhpcy5taW51c1N5bWJvbCk7XG59O1xuXG5OdW1iZXJGb3JtYXQucHJvdG90eXBlLmluc2VydEN1cnJlbmN5U3ltYm9sID0gZnVuY3Rpb24gaW5zZXJ0Q3VycmVuY3lTeW1ib2woc3RyLCBuZWdhdGl2ZSkge1xuICByZXR1cm4gXCJcIiArIChuZWdhdGl2ZSA/IHRoaXMubmVnYXRpdmVQcmVmaXggOiB0aGlzLnByZWZpeCkgKyBzdHIgKyB0aGlzLnN1ZmZpeDtcbn07XG5cbk51bWJlckZvcm1hdC5wcm90b3R5cGUuc3RyaXBNaW51c1N5bWJvbCA9IGZ1bmN0aW9uIHN0cmlwTWludXNTeW1ib2woc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgnLScsIHRoaXMubWludXNTeW1ib2wpLnJlcGxhY2UodGhpcy5taW51c1N5bWJvbCwgJycpO1xufTtcblxuTnVtYmVyRm9ybWF0LnByb3RvdHlwZS5zdHJpcEN1cnJlbmN5U3ltYm9sID0gZnVuY3Rpb24gc3RyaXBDdXJyZW5jeVN5bWJvbChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHRoaXMubmVnYXRpdmVQcmVmaXgsICcnKS5yZXBsYWNlKHRoaXMucHJlZml4LCAnJykucmVwbGFjZSh0aGlzLnN1ZmZpeCwgJycpO1xufTtcblxuTnVtYmVyRm9ybWF0LnByb3RvdHlwZS5ub3JtYWxpemVEZWNpbWFsU3ltYm9sID0gZnVuY3Rpb24gbm9ybWFsaXplRGVjaW1hbFN5bWJvbChzdHIsIGZyb20pIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gIERFQ0lNQUxfU1lNQk9MUy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgc3RyID0gc3RyLnN1YnN0cigwLCBmcm9tKSArIHN0ci5zdWJzdHIoZnJvbSkucmVwbGFjZShzLCB0aGlzJDEuZGVjaW1hbFN5bWJvbCk7XG4gIH0pO1xuICByZXR1cm4gc3RyO1xufTtcblxuTnVtYmVyRm9ybWF0LnByb3RvdHlwZS5ub3JtYWxpemVEaWdpdHMgPSBmdW5jdGlvbiBub3JtYWxpemVEaWdpdHMoc3RyKSB7XG4gIGlmICh0aGlzLmRpZ2l0c1swXSAhPT0gJzAnKSB7XG4gICAgdGhpcy5kaWdpdHMuZm9yRWFjaChmdW5jdGlvbiAoZGlnaXQsIGluZGV4KSB7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZShuZXcgUmVnRXhwKGRpZ2l0LCAnZycpLCBpbmRleCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxuTnVtYmVyRm9ybWF0LnByb3RvdHlwZS5vbmx5RGlnaXRzID0gZnVuY3Rpb24gb25seURpZ2l0cyhzdHIpIHtcbiAgcmV0dXJuIHRoaXMubm9ybWFsaXplRGlnaXRzKHN0cikucmVwbGFjZSgvXFxEKy9nLCAnJyk7XG59O1xuXG5OdW1iZXJGb3JtYXQucHJvdG90eXBlLm9ubHlMb2NhbGVEaWdpdHMgPSBmdW5jdGlvbiBvbmx5TG9jYWxlRGlnaXRzKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChcIlteXCIgKyB0aGlzLmRpZ2l0cy5qb2luKCcnKSArIFwiXSpcIiwgJ2cnKSwgJycpO1xufTtcblxudmFyIERlZmF1bHROdW1iZXJNYXNrID0gZnVuY3Rpb24gRGVmYXVsdE51bWJlck1hc2sobnVtYmVyRm9ybWF0KSB7XG4gIHRoaXMubnVtYmVyRm9ybWF0ID0gbnVtYmVyRm9ybWF0O1xufTtcblxuRGVmYXVsdE51bWJlck1hc2sucHJvdG90eXBlLmNvbmZvcm1Ub01hc2sgPSBmdW5jdGlvbiBjb25mb3JtVG9NYXNrKHN0ciwgcHJldmlvdXNDb25mb3JtZWRWYWx1ZSkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcbiAgaWYgKHByZXZpb3VzQ29uZm9ybWVkVmFsdWUgPT09IHZvaWQgMCkgcHJldmlvdXNDb25mb3JtZWRWYWx1ZSA9ICcnO1xuICB2YXIgbmVnYXRpdmUgPSB0aGlzLm51bWJlckZvcm1hdC5pc05lZ2F0aXZlKHN0cik7XG5cbiAgdmFyIGNoZWNrSW5jb21wbGV0ZVZhbHVlID0gZnVuY3Rpb24gY2hlY2tJbmNvbXBsZXRlVmFsdWUoc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gJycgJiYgbmVnYXRpdmUgJiYgcHJldmlvdXNDb25mb3JtZWRWYWx1ZSAhPT0gdGhpcyQxLm51bWJlckZvcm1hdC5uZWdhdGl2ZVByZWZpeCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSBpZiAodGhpcyQxLm51bWJlckZvcm1hdC5tYXhpbXVtRnJhY3Rpb25EaWdpdHMgPiAwKSB7XG4gICAgICBpZiAodGhpcyQxLm51bWJlckZvcm1hdC5pc0ZyYWN0aW9uSW5jb21wbGV0ZShzdHIpKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0c1dpdGgoc3RyLCB0aGlzJDEubnVtYmVyRm9ybWF0LmRlY2ltYWxTeW1ib2wpKSB7XG4gICAgICAgIHJldHVybiB0aGlzJDEubnVtYmVyRm9ybWF0LnRvRnJhY3Rpb24oc3RyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICB2YXIgdmFsdWUgPSBzdHI7XG4gIHZhbHVlID0gdGhpcy5udW1iZXJGb3JtYXQuc3RyaXBDdXJyZW5jeVN5bWJvbCh2YWx1ZSk7XG4gIHZhbHVlID0gdGhpcy5udW1iZXJGb3JtYXQuc3RyaXBNaW51c1N5bWJvbCh2YWx1ZSk7XG4gIHZhciBpbmNvbXBsZXRlVmFsdWUgPSBjaGVja0luY29tcGxldGVWYWx1ZSh2YWx1ZSk7XG5cbiAgaWYgKGluY29tcGxldGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMubnVtYmVyRm9ybWF0Lmluc2VydEN1cnJlbmN5U3ltYm9sKGluY29tcGxldGVWYWx1ZSwgbmVnYXRpdmUpO1xuICB9XG5cbiAgdmFyIHJlZiA9IHZhbHVlLnNwbGl0KHRoaXMubnVtYmVyRm9ybWF0LmRlY2ltYWxTeW1ib2wpO1xuICB2YXIgaW50ZWdlciA9IHJlZlswXTtcbiAgdmFyIGZyYWN0aW9uID0gcmVmLnNsaWNlKDEpO1xuICB2YXIgaW50ZWdlckRpZ2l0cyA9IHJlbW92ZUxlYWRpbmdaZXJvcyh0aGlzLm51bWJlckZvcm1hdC5vbmx5RGlnaXRzKGludGVnZXIpKTtcbiAgdmFyIGZyYWN0aW9uRGlnaXRzID0gdGhpcy5udW1iZXJGb3JtYXQub25seURpZ2l0cyhmcmFjdGlvbi5qb2luKCcnKSkuc3Vic3RyKDAsIHRoaXMubnVtYmVyRm9ybWF0Lm1heGltdW1GcmFjdGlvbkRpZ2l0cyk7XG4gIHZhciBpbnZhbGlkRnJhY3Rpb24gPSBmcmFjdGlvbi5sZW5ndGggPiAwICYmIGZyYWN0aW9uRGlnaXRzLmxlbmd0aCA9PT0gMDtcbiAgdmFyIGludmFsaWROZWdhdGl2ZVZhbHVlID0gaW50ZWdlckRpZ2l0cyA9PT0gJycgJiYgbmVnYXRpdmUgJiYgKHByZXZpb3VzQ29uZm9ybWVkVmFsdWUgPT09IHN0ci5zbGljZSgwLCAtMSkgfHwgcHJldmlvdXNDb25mb3JtZWRWYWx1ZSAhPT0gdGhpcy5udW1iZXJGb3JtYXQubmVnYXRpdmVQcmVmaXgpO1xuXG4gIGlmIChpbnZhbGlkRnJhY3Rpb24gfHwgaW52YWxpZE5lZ2F0aXZlVmFsdWUpIHtcbiAgICByZXR1cm4gcHJldmlvdXNDb25mb3JtZWRWYWx1ZTtcbiAgfSBlbHNlIGlmIChpbnRlZ2VyRGlnaXRzLm1hdGNoKC9cXGQrLykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbnVtYmVyVmFsdWU6IE51bWJlcihcIlwiICsgKG5lZ2F0aXZlID8gJy0nIDogJycpICsgaW50ZWdlckRpZ2l0cyArIFwiLlwiICsgZnJhY3Rpb25EaWdpdHMpLFxuICAgICAgZnJhY3Rpb25EaWdpdHM6IGZyYWN0aW9uRGlnaXRzXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbnZhciBBdXRvRGVjaW1hbE1vZGVOdW1iZXJNYXNrID0gZnVuY3Rpb24gQXV0b0RlY2ltYWxNb2RlTnVtYmVyTWFzayhudW1iZXJGb3JtYXQpIHtcbiAgdGhpcy5udW1iZXJGb3JtYXQgPSBudW1iZXJGb3JtYXQ7XG59O1xuXG5BdXRvRGVjaW1hbE1vZGVOdW1iZXJNYXNrLnByb3RvdHlwZS5jb25mb3JtVG9NYXNrID0gZnVuY3Rpb24gY29uZm9ybVRvTWFzayhzdHIpIHtcbiAgaWYgKHN0ciA9PT0gJycpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgbmVnYXRpdmUgPSB0aGlzLm51bWJlckZvcm1hdC5pc05lZ2F0aXZlKHN0cik7XG4gIHZhciBudW1iZXJWYWx1ZSA9IHRoaXMubnVtYmVyRm9ybWF0LnN0cmlwTWludXNTeW1ib2woc3RyKSA9PT0gJycgPyAtMCA6IE51bWJlcihcIlwiICsgKG5lZ2F0aXZlID8gJy0nIDogJycpICsgcmVtb3ZlTGVhZGluZ1plcm9zKHRoaXMubnVtYmVyRm9ybWF0Lm9ubHlEaWdpdHMoc3RyKSkpIC8gTWF0aC5wb3coMTAsIHRoaXMubnVtYmVyRm9ybWF0Lm1pbmltdW1GcmFjdGlvbkRpZ2l0cyk7XG4gIHJldHVybiB7XG4gICAgbnVtYmVyVmFsdWU6IG51bWJlclZhbHVlLFxuICAgIGZyYWN0aW9uRGlnaXRzOiBudW1iZXJWYWx1ZS50b0ZpeGVkKHRoaXMubnVtYmVyRm9ybWF0Lm1pbmltdW1GcmFjdGlvbkRpZ2l0cykuc2xpY2UoLXRoaXMubnVtYmVyRm9ybWF0Lm1pbmltdW1GcmFjdGlvbkRpZ2l0cylcbiAgfTtcbn07XG5cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcblxudmFyIGluaXQgPSBmdW5jdGlvbiBpbml0KGVsLCBvcHRpb25zRnJvbUJpbmRpbmcsIHJlZikge1xuICB2YXIgJGNpID0gcmVmLiRjaTtcbiAgdmFyIGlucHV0RWxlbWVudCA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyA/IGVsIDogZWwucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcblxuICBpZiAoIWlucHV0RWxlbWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5wdXQgZWxlbWVudCBmb3VuZCcpO1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCAkY2kgPyAkY2kuR0xPQkFMX09QVElPTlMgOiBERUZBVUxUX09QVElPTlMsIG9wdGlvbnNGcm9tQmluZGluZyk7XG4gIHZhciBkaXN0cmFjdGlvbkZyZWUgPSBvcHRpb25zLmRpc3RyYWN0aW9uRnJlZTtcbiAgdmFyIGF1dG9EZWNpbWFsTW9kZSA9IG9wdGlvbnMuYXV0b0RlY2ltYWxNb2RlO1xuICB2YXIgdmFsdWVSYW5nZSA9IG9wdGlvbnMudmFsdWVSYW5nZTtcblxuICBpZiAodHlwZW9mIGRpc3RyYWN0aW9uRnJlZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucy5kaXN0cmFjdGlvbkZyZWUgPSB7XG4gICAgICBoaWRlQ3VycmVuY3lTeW1ib2w6IGRpc3RyYWN0aW9uRnJlZSxcbiAgICAgIGhpZGVOZWdsaWdpYmxlRGVjaW1hbERpZ2l0czogZGlzdHJhY3Rpb25GcmVlLFxuICAgICAgaGlkZUdyb3VwaW5nU3ltYm9sOiBkaXN0cmFjdGlvbkZyZWVcbiAgICB9O1xuICB9XG5cbiAgaWYgKHZhbHVlUmFuZ2UpIHtcbiAgICBvcHRpb25zLnZhbHVlUmFuZ2UgPSB7XG4gICAgICBtaW46IHZhbHVlUmFuZ2UubWluICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCh2YWx1ZVJhbmdlLm1pbiwgLU1BWF9TQUZFX0lOVEVHRVIpIDogLU1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICBtYXg6IHZhbHVlUmFuZ2UubWF4ICE9PSB1bmRlZmluZWQgPyBNYXRoLm1pbih2YWx1ZVJhbmdlLm1heCwgTUFYX1NBRkVfSU5URUdFUikgOiBNQVhfU0FGRV9JTlRFR0VSXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLnZhbHVlUmFuZ2UgPSB7XG4gICAgICBtaW46IC1NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgbWF4OiBNQVhfU0FGRV9JTlRFR0VSXG4gICAgfTtcbiAgfVxuXG4gIGlmIChhdXRvRGVjaW1hbE1vZGUpIHtcbiAgICBvcHRpb25zLmRpc3RyYWN0aW9uRnJlZS5oaWRlTmVnbGlnaWJsZURlY2ltYWxEaWdpdHMgPSBmYWxzZTtcbiAgICBpbnB1dEVsZW1lbnQuc2V0QXR0cmlidXRlKCdpbnB1dG1vZGUnLCAnbnVtZXJpYycpO1xuICB9IGVsc2Uge1xuICAgIGlucHV0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lucHV0bW9kZScsICdkZWNpbWFsJyk7XG4gIH1cblxuICB2YXIgY3VycmVuY3lGb3JtYXQgPSBuZXcgTnVtYmVyRm9ybWF0KG9wdGlvbnMpO1xuICBpbnB1dEVsZW1lbnQuJGNpID0gT2JqZWN0LmFzc2lnbih7fSwgaW5wdXRFbGVtZW50LiRjaSB8fCB7XG4gICAgbnVtYmVyVmFsdWU6IG51bGxcbiAgfSwge1xuICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgbnVtYmVyTWFzazogb3B0aW9ucy5hdXRvRGVjaW1hbE1vZGUgPyBuZXcgQXV0b0RlY2ltYWxNb2RlTnVtYmVyTWFzayhjdXJyZW5jeUZvcm1hdCkgOiBuZXcgRGVmYXVsdE51bWJlck1hc2soY3VycmVuY3lGb3JtYXQpLFxuICAgIGN1cnJlbmN5Rm9ybWF0OiBjdXJyZW5jeUZvcm1hdFxuICB9KTtcbiAgcmV0dXJuIGlucHV0RWxlbWVudDtcbn07XG5cbnZhciB0cmlnZ2VyRXZlbnQgPSBmdW5jdGlvbiB0cmlnZ2VyRXZlbnQoZWwsIGV2ZW50TmFtZSkge1xuICB2YXIgcmVmID0gZWwuJGNpO1xuICB2YXIgbnVtYmVyVmFsdWUgPSByZWYubnVtYmVyVmFsdWU7XG4gIHZhciBjdXJyZW5jeUZvcm1hdCA9IHJlZi5jdXJyZW5jeUZvcm1hdDtcbiAgdmFyIG9wdGlvbnMgPSByZWYub3B0aW9ucztcbiAgbnVtYmVyVmFsdWUgPSB0b0V4dGVybmFsTnVtYmVyTW9kZWwobnVtYmVyVmFsdWUsIG9wdGlvbnMudmFsdWVBc0ludGVnZXIsIGN1cnJlbmN5Rm9ybWF0Lm1heGltdW1GcmFjdGlvbkRpZ2l0cyk7XG4gIGRpc3BhdGNoRXZlbnQkMShlbCwgZXZlbnROYW1lLCB7XG4gICAgbnVtYmVyVmFsdWU6IG51bWJlclZhbHVlXG4gIH0pO1xufTtcblxudmFyIGFwcGx5Rml4ZWRGcmFjdGlvbkZvcm1hdCA9IGZ1bmN0aW9uIGFwcGx5Rml4ZWRGcmFjdGlvbkZvcm1hdChlbCwgdmFsdWUsIGZvcmNlZENoYW5nZSkge1xuICBpZiAoZm9yY2VkQ2hhbmdlID09PSB2b2lkIDApIGZvcmNlZENoYW5nZSA9IGZhbHNlO1xuICB2YXIgcmVmID0gZWwuJGNpO1xuICB2YXIgY3VycmVuY3lGb3JtYXQgPSByZWYuY3VycmVuY3lGb3JtYXQ7XG4gIHZhciBvcHRpb25zID0gcmVmLm9wdGlvbnM7XG4gIHZhciByZWYkMSA9IG9wdGlvbnMudmFsdWVSYW5nZTtcbiAgdmFyIG1pbiA9IHJlZiQxLm1pbjtcbiAgdmFyIG1heCA9IHJlZiQxLm1heDtcblxuICB2YXIgdmFsaWRhdGVWYWx1ZVJhbmdlID0gZnVuY3Rpb24gdmFsaWRhdGVWYWx1ZVJhbmdlKCkge1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcbiAgfTtcblxuICBmb3JtYXQoZWwsIHZhbHVlICE9IG51bGwgPyBjdXJyZW5jeUZvcm1hdC5mb3JtYXQodmFsaWRhdGVWYWx1ZVJhbmdlKCkpIDogbnVsbCk7XG5cbiAgaWYgKHZhbHVlICE9PSBlbC4kY2kubnVtYmVyVmFsdWUgfHwgZm9yY2VkQ2hhbmdlKSB7XG4gICAgdHJpZ2dlckV2ZW50KGVsLCAnY2hhbmdlJyk7XG4gIH1cbn07XG5cbnZhciB1cGRhdGVJbnB1dFZhbHVlID0gZnVuY3Rpb24gdXBkYXRlSW5wdXRWYWx1ZShlbCwgdmFsdWUsIGhpZGVOZWdsaWdpYmxlRGVjaW1hbERpZ2l0cykge1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHZhciByZWYgPSBlbC4kY2k7XG4gICAgdmFyIGZvY3VzID0gcmVmLmZvY3VzO1xuICAgIHZhciBkZWNpbWFsU3ltYm9sSW5zZXJ0ZWRBdCA9IHJlZi5kZWNpbWFsU3ltYm9sSW5zZXJ0ZWRBdDtcbiAgICB2YXIgb3B0aW9ucyA9IHJlZi5vcHRpb25zO1xuICAgIHZhciBudW1iZXJNYXNrID0gcmVmLm51bWJlck1hc2s7XG4gICAgdmFyIGN1cnJlbmN5Rm9ybWF0ID0gcmVmLmN1cnJlbmN5Rm9ybWF0O1xuICAgIHZhciBwcmV2aW91c0NvbmZvcm1lZFZhbHVlID0gcmVmLnByZXZpb3VzQ29uZm9ybWVkVmFsdWU7XG4gICAgdmFyIGFsbG93TmVnYXRpdmUgPSBvcHRpb25zLmFsbG93TmVnYXRpdmU7XG4gICAgdmFyIGRpc3RyYWN0aW9uRnJlZSA9IG9wdGlvbnMuZGlzdHJhY3Rpb25GcmVlO1xuXG4gICAgaWYgKGRlY2ltYWxTeW1ib2xJbnNlcnRlZEF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0gY3VycmVuY3lGb3JtYXQubm9ybWFsaXplRGVjaW1hbFN5bWJvbCh2YWx1ZSwgZGVjaW1hbFN5bWJvbEluc2VydGVkQXQpO1xuICAgICAgZWwuJGNpLmRlY2ltYWxTeW1ib2xJbnNlcnRlZEF0ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBjb25mb3JtZWRWYWx1ZSA9IG51bWJlck1hc2suY29uZm9ybVRvTWFzayh2YWx1ZSwgcHJldmlvdXNDb25mb3JtZWRWYWx1ZSk7XG4gICAgdmFyIGZvcm1hdHRlZFZhbHVlO1xuXG4gICAgaWYgKF90eXBlb2YoY29uZm9ybWVkVmFsdWUpID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIG51bWJlclZhbHVlID0gY29uZm9ybWVkVmFsdWUubnVtYmVyVmFsdWU7XG4gICAgICB2YXIgZnJhY3Rpb25EaWdpdHMgPSBjb25mb3JtZWRWYWx1ZS5mcmFjdGlvbkRpZ2l0cztcbiAgICAgIHZhciBtYXhpbXVtRnJhY3Rpb25EaWdpdHMgPSBjdXJyZW5jeUZvcm1hdC5tYXhpbXVtRnJhY3Rpb25EaWdpdHM7XG4gICAgICB2YXIgbWluaW11bUZyYWN0aW9uRGlnaXRzID0gY3VycmVuY3lGb3JtYXQubWluaW11bUZyYWN0aW9uRGlnaXRzO1xuXG4gICAgICBpZiAoZm9jdXMpIHtcbiAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzID0gbWF4aW11bUZyYWN0aW9uRGlnaXRzO1xuICAgICAgfVxuXG4gICAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgPSBoaWRlTmVnbGlnaWJsZURlY2ltYWxEaWdpdHMgPyBmcmFjdGlvbkRpZ2l0cy5yZXBsYWNlKC8wKyQvLCAnJykubGVuZ3RoIDogTWF0aC5taW4obWluaW11bUZyYWN0aW9uRGlnaXRzLCBmcmFjdGlvbkRpZ2l0cy5sZW5ndGgpO1xuICAgICAgZm9ybWF0dGVkVmFsdWUgPSBudW1iZXJWYWx1ZSA+IE1BWF9TQUZFX0lOVEVHRVIgPyBwcmV2aW91c0NvbmZvcm1lZFZhbHVlIDogY3VycmVuY3lGb3JtYXQuZm9ybWF0KG51bWJlclZhbHVlLCB7XG4gICAgICAgIHVzZUdyb3VwaW5nOiAhKGZvY3VzICYmIGRpc3RyYWN0aW9uRnJlZS5oaWRlR3JvdXBpbmdTeW1ib2wpLFxuICAgICAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IG1pbmltdW1GcmFjdGlvbkRpZ2l0cyxcbiAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBtYXhpbXVtRnJhY3Rpb25EaWdpdHNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JtYXR0ZWRWYWx1ZSA9IGNvbmZvcm1lZFZhbHVlO1xuICAgIH1cblxuICAgIGlmICghYWxsb3dOZWdhdGl2ZSkge1xuICAgICAgZm9ybWF0dGVkVmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZS5yZXBsYWNlKGN1cnJlbmN5Rm9ybWF0Lm5lZ2F0aXZlUHJlZml4LCBjdXJyZW5jeUZvcm1hdC5wcmVmaXgpO1xuICAgIH1cblxuICAgIGlmIChmb2N1cyAmJiBkaXN0cmFjdGlvbkZyZWUuaGlkZUN1cnJlbmN5U3ltYm9sKSB7XG4gICAgICBmb3JtYXR0ZWRWYWx1ZSA9IGZvcm1hdHRlZFZhbHVlLnJlcGxhY2UoY3VycmVuY3lGb3JtYXQubmVnYXRpdmVQcmVmaXgsIGN1cnJlbmN5Rm9ybWF0Lm1pbnVzU3ltYm9sKS5yZXBsYWNlKGN1cnJlbmN5Rm9ybWF0LnByZWZpeCwgJycpLnJlcGxhY2UoY3VycmVuY3lGb3JtYXQuc3VmZml4LCAnJyk7XG4gICAgfVxuXG4gICAgZWwudmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICBlbC4kY2kubnVtYmVyVmFsdWUgPSBjdXJyZW5jeUZvcm1hdC5wYXJzZShlbC52YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZWwudmFsdWUgPSBlbC4kY2kubnVtYmVyVmFsdWUgPSBudWxsO1xuICB9XG5cbiAgZWwuJGNpLnByZXZpb3VzQ29uZm9ybWVkVmFsdWUgPSBlbC52YWx1ZTtcbn07XG5cbnZhciBmb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQoZWwsIHZhbHVlLCBoaWRlTmVnbGlnaWJsZURlY2ltYWxEaWdpdHMpIHtcbiAgaWYgKGhpZGVOZWdsaWdpYmxlRGVjaW1hbERpZ2l0cyA9PT0gdm9pZCAwKSBoaWRlTmVnbGlnaWJsZURlY2ltYWxEaWdpdHMgPSBmYWxzZTtcbiAgdXBkYXRlSW5wdXRWYWx1ZShlbCwgdmFsdWUsIGhpZGVOZWdsaWdpYmxlRGVjaW1hbERpZ2l0cyk7XG4gIHRyaWdnZXJFdmVudChlbCwgJ2lucHV0Jyk7XG59O1xuXG52YXIgYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWwpIHtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmICghZS5kZXRhaWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGVsLnZhbHVlO1xuICAgICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gZWwuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB2YXIgZWxfJGNpID0gZWwuJGNpO1xuICAgICAgdmFyIGN1cnJlbmN5Rm9ybWF0ID0gZWxfJGNpLmN1cnJlbmN5Rm9ybWF0O1xuICAgICAgdmFyIG9wdGlvbnMgPSBlbF8kY2kub3B0aW9ucztcbiAgICAgIGZvcm1hdChlbCwgdmFsdWUpO1xuXG4gICAgICBpZiAoZWwuJGNpLmZvY3VzKSB7XG4gICAgICAgIHNldENhcmV0UG9zaXRpb24oZWwsIGdldENhcmV0UG9zaXRpb25BZnRlckZvcm1hdChlbC52YWx1ZSwgdmFsdWUsIHNlbGVjdGlvblN0YXJ0LCBjdXJyZW5jeUZvcm1hdCwgb3B0aW9ucykpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGNhcHR1cmU6IHRydWVcbiAgfSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoREVDSU1BTF9TWU1CT0xTLmluY2x1ZGVzKGUua2V5KSkge1xuICAgICAgZWwuJGNpLmRlY2ltYWxTeW1ib2xJbnNlcnRlZEF0ID0gZWwuc2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuICB9KTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcignZm9ybWF0JywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgcmVmID0gZWwuJGNpO1xuICAgIHZhciBjdXJyZW5jeUZvcm1hdCA9IHJlZi5jdXJyZW5jeUZvcm1hdDtcbiAgICB2YXIgb3B0aW9ucyA9IHJlZi5vcHRpb25zO1xuICAgIHZhciBudW1iZXJWYWx1ZSA9IHJlZi5udW1iZXJWYWx1ZTtcblxuICAgIHZhciB0b0ludGVybmFsTnVtYmVyTW9kZWwgPSBmdW5jdGlvbiB0b0ludGVybmFsTnVtYmVyTW9kZWwobikge1xuICAgICAgcmV0dXJuIG9wdGlvbnMudmFsdWVBc0ludGVnZXIgJiYgbiAhPSBudWxsID8gbiAvIE1hdGgucG93KDEwLCBjdXJyZW5jeUZvcm1hdC5tYXhpbXVtRnJhY3Rpb25EaWdpdHMpIDogbjtcbiAgICB9O1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gdG9JbnRlcm5hbE51bWJlck1vZGVsKGUuZGV0YWlsLnZhbHVlKTtcblxuICAgIGlmIChudW1iZXJWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgIGFwcGx5Rml4ZWRGcmFjdGlvbkZvcm1hdChlbCwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuICAgIGVsLiRjaS5mb2N1cyA9IHRydWU7XG4gICAgdmFyIHJlZiA9IGVsLiRjaS5vcHRpb25zLmRpc3RyYWN0aW9uRnJlZTtcbiAgICB2YXIgaGlkZUN1cnJlbmN5U3ltYm9sID0gcmVmLmhpZGVDdXJyZW5jeVN5bWJvbDtcbiAgICB2YXIgaGlkZUdyb3VwaW5nU3ltYm9sID0gcmVmLmhpZGVHcm91cGluZ1N5bWJvbDtcbiAgICB2YXIgaGlkZU5lZ2xpZ2libGVEZWNpbWFsRGlnaXRzID0gcmVmLmhpZGVOZWdsaWdpYmxlRGVjaW1hbERpZ2l0cztcblxuICAgIGlmIChoaWRlQ3VycmVuY3lTeW1ib2wgfHwgaGlkZUdyb3VwaW5nU3ltYm9sIHx8IGhpZGVOZWdsaWdpYmxlRGVjaW1hbERpZ2l0cykge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGVsLnZhbHVlO1xuICAgICAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSBlbC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkVuZCA9IGVsLnNlbGVjdGlvbkVuZDtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBmb3JtYXQoZWwsIHZhbHVlLCBoaWRlTmVnbGlnaWJsZURlY2ltYWxEaWdpdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHNlbGVjdGlvblN0YXJ0IC0gc2VsZWN0aW9uRW5kKSA+IDApIHtcbiAgICAgICAgICBlbC5zZXRTZWxlY3Rpb25SYW5nZSgwLCBlbC52YWx1ZS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldENhcmV0UG9zaXRpb24oZWwsIGdldERpc3RyYWN0aW9uRnJlZUNhcmV0UG9zaXRpb24oZWwuJGNpLmN1cnJlbmN5Rm9ybWF0LCBlbC4kY2kub3B0aW9ucywgdmFsdWUsIHNlbGVjdGlvblN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbiAoKSB7XG4gICAgZWwuJGNpLmZvY3VzID0gZmFsc2U7XG5cbiAgICBpZiAoZWwuJGNpLm51bWJlclZhbHVlICE9IG51bGwpIHtcbiAgICAgIGFwcGx5Rml4ZWRGcmFjdGlvbkZvcm1hdChlbCwgZWwuJGNpLm51bWJlclZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmICghZS5kZXRhaWwpIHtcbiAgICAgIHRyaWdnZXJFdmVudChlbCwgJ2NoYW5nZScpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgZGlyZWN0aXZlID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kKGVsLCByZWYsIHJlZiQxKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBjb250ZXh0ID0gcmVmJDEuY29udGV4dDtcbiAgICB2YXIgaW5wdXRFbGVtZW50ID0gaW5pdChlbCwgdmFsdWUsIGNvbnRleHQpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoaW5wdXRFbGVtZW50KTtcbiAgICBzZXRWYWx1ZSQxKGlucHV0RWxlbWVudCwgaW5wdXRFbGVtZW50LiRjaS5jdXJyZW5jeUZvcm1hdC5wYXJzZShpbnB1dEVsZW1lbnQudmFsdWUpKTtcbiAgfSxcbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZChlbCwgcmVmLCByZWYkMSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG4gICAgdmFyIGNvbnRleHQgPSByZWYkMS5jb250ZXh0O1xuXG4gICAgaWYgKCFlcXVhbCh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICB2YXIgaW5wdXRFbGVtZW50ID0gaW5pdChlbCwgdmFsdWUsIGNvbnRleHQpO1xuICAgICAgYXBwbHlGaXhlZEZyYWN0aW9uRm9ybWF0KGlucHV0RWxlbWVudCwgaW5wdXRFbGVtZW50LiRjaS5udW1iZXJWYWx1ZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG59O1xudmFyIGNvbXBvbmVudCA9IHtcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgIHJldHVybiBoKCdpbnB1dCcsIHtcbiAgICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICAgIG5hbWU6ICdjdXJyZW5jeScsXG4gICAgICAgIHZhbHVlOiB0aGlzLm9wdGlvbnNcbiAgICAgIH1dLFxuICAgICAgb246IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuJGxpc3RlbmVycywge1xuICAgICAgICBjaGFuZ2U6IGZ1bmN0aW9uIGNoYW5nZShlKSB7XG4gICAgICAgICAgaWYgKGUuZGV0YWlsKSB7XG4gICAgICAgICAgICB0aGlzJDEuJGVtaXQoJ2NoYW5nZScsIGUuZGV0YWlsLm51bWJlclZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0OiBmdW5jdGlvbiBpbnB1dChlKSB7XG4gICAgICAgICAgaWYgKGUuZGV0YWlsICYmIHRoaXMkMS52YWx1ZSAhPT0gZS5kZXRhaWwubnVtYmVyVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMkMS4kZW1pdCgnaW5wdXQnLCBlLmRldGFpbC5udW1iZXJWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pO1xuICB9LFxuICBkaXJlY3RpdmVzOiB7XG4gICAgY3VycmVuY3k6IGRpcmVjdGl2ZVxuICB9LFxuICBuYW1lOiAnQ3VycmVuY3lJbnB1dCcsXG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIGxvY2FsZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICBjdXJyZW5jeToge1xuICAgICAgdHlwZTogW1N0cmluZywgT2JqZWN0XSxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgZGlzdHJhY3Rpb25GcmVlOiB7XG4gICAgICB0eXBlOiBbQm9vbGVhbiwgT2JqZWN0XSxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgcHJlY2lzaW9uOiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBPYmplY3RdLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICBhdXRvRGVjaW1hbE1vZGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICB9LFxuICAgIHZhbHVlQXNJbnRlZ2VyOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICB2YWx1ZVJhbmdlOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICB9LFxuICAgIGFsbG93TmVnYXRpdmU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5zZXRWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBvcHRpb25zOiBmdW5jdGlvbiBvcHRpb25zKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgICB2YXIgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuJGNpID8gdGhpcy4kY2kuR0xPQkFMX09QVElPTlMgOiBERUZBVUxUX09QVElPTlMpO1xuICAgICAgT2JqZWN0LmtleXMoREVGQVVMVF9PUFRJT05TKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMkMVtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRpb25zW2tleV0gPSB0aGlzJDFba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgdmFsdWU6ICdzZXRWYWx1ZSdcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHNldFZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSQxJDEodmFsdWUpIHtcbiAgICAgIHNldFZhbHVlJDEodGhpcy4kZWwsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn07XG52YXIgcGx1Z2luID0ge1xuICBpbnN0YWxsOiBmdW5jdGlvbiBpbnN0YWxsKFZ1ZSwgcmVmKSB7XG4gICAgaWYgKHJlZiA9PT0gdm9pZCAwKSByZWYgPSB7fTtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IHJlZi5jb21wb25lbnROYW1lO1xuICAgIGlmIChjb21wb25lbnROYW1lID09PSB2b2lkIDApIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQubmFtZTtcbiAgICB2YXIgZGlyZWN0aXZlTmFtZSA9IHJlZi5kaXJlY3RpdmVOYW1lO1xuICAgIGlmIChkaXJlY3RpdmVOYW1lID09PSB2b2lkIDApIGRpcmVjdGl2ZU5hbWUgPSAnY3VycmVuY3knO1xuICAgIHZhciBnbG9iYWxPcHRpb25zID0gcmVmLmdsb2JhbE9wdGlvbnM7XG4gICAgaWYgKGdsb2JhbE9wdGlvbnMgPT09IHZvaWQgMCkgZ2xvYmFsT3B0aW9ucyA9IHt9O1xuICAgIFZ1ZS5jb21wb25lbnQoY29tcG9uZW50TmFtZSwgY29tcG9uZW50KTtcbiAgICBWdWUuZGlyZWN0aXZlKGRpcmVjdGl2ZU5hbWUsIGRpcmVjdGl2ZSk7XG4gICAgVnVlLnByb3RvdHlwZS4kY2kgPSB7XG4gICAgICBnZXRWYWx1ZTogZ2V0VmFsdWUsXG4gICAgICBzZXRWYWx1ZTogc2V0VmFsdWUkMSxcbiAgICAgIEdMT0JBTF9PUFRJT05TOiBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIGdsb2JhbE9wdGlvbnMpXG4gICAgfTtcbiAgfVxufTtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WdWUpIHtcbiAgd2luZG93LlZ1ZS51c2UocGx1Z2luKTtcbn1cblxudmFyIG9wdGlvbnMgPSB7XG4gIGxvY2FsZTogdW5kZWZpbmVkLFxuICBjdXJyZW5jeTogdW5kZWZpbmVkLFxuICBkZWNpbWFsTGVuZ3RoOiAyLFxuICBhdXRvRGVjaW1hbE1vZGU6IHRydWUsXG4gIG1pbjogbnVsbCxcbiAgbWF4OiBudWxsLFxuICBkZWZhdWx0VmFsdWU6IDAsXG4gIHZhbHVlQXNJbnRlZ2VyOiBmYWxzZSxcbiAgYWxsb3dOZWdhdGl2ZTogdHJ1ZVxufTtcblxudmFyIHNjcmlwdCA9IHtcbiAgbmFtZTogJ1ZDdXJyZW5jeUZpZWxkJyxcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxvY2FsZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmxvY2FsZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGN1cnJlbmN5OiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmN1cnJlbmN5O1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVjaW1hbExlbmd0aDoge1xuICAgICAgdHlwZTogW051bWJlciwgT2JqZWN0XSxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5kZWNpbWFsTGVuZ3RoO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXV0b0RlY2ltYWxNb2RlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmF1dG9EZWNpbWFsTW9kZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1pbjoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLm1pbjtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1heDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLm1heDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlZmF1bHRWYWx1ZToge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbHVlQXNJbnRlZ2VyOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnZhbHVlQXNJbnRlZ2VyO1xuICAgICAgfVxuICAgIH0sXG4gICAgYWxsb3dOZWdhdGl2ZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5hbGxvd05lZ2F0aXZlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGlyZWN0aXZlczoge1xuICAgIEN1cnJlbmN5RGlyZWN0aXZlOiBkaXJlY3RpdmVcbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybWF0dGVkVmFsdWU6IHRoaXMudmFsdWVcbiAgICB9O1xuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHRoaXMuYWRkTGlzdGVuZXJzKHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0JykpO1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGF0dHJzOiBmdW5jdGlvbiBhdHRycygpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgdmFyIF90aGlzJCRhdHRycyA9IHRoaXMuJGF0dHJzLFxuICAgICAgICAgIHZhbHVlID0gX3RoaXMkJGF0dHJzLnZhbHVlLFxuICAgICAgICAgIGF0dHJzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJCRhdHRycywgW1widmFsdWVcIl0pOyAvLyBhbGwgYnV0IGlucHV0IGV2ZW50XG5cblxuICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH0sXG4gICAgZGlzdHJhY3Rpb25GcmVlOiBmdW5jdGlvbiBkaXN0cmFjdGlvbkZyZWUoKSB7XG4gICAgICBpZiAodGhpcy5kZWNpbWFsTGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuYXV0b0RlY2ltYWxNb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVjaW1hbE1vZGU6IGZ1bmN0aW9uIGRlY2ltYWxNb2RlKCkge1xuICAgICAgaWYgKHRoaXMuZGVjaW1hbExlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0b0RlY2ltYWxNb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsdWVSYW5nZTogZnVuY3Rpb24gdmFsdWVSYW5nZSgpIHtcbiAgICAgIGlmICh0aGlzLm1pbiB8fCB0aGlzLm1heCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1pbjogdGhpcy5taW4sXG4gICAgICAgICAgbWF4OiB0aGlzLm1heFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgdmFsdWU6ICdzZXRWYWx1ZSdcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGFkZExpc3RlbmVyczogZnVuY3Rpb24gYWRkTGlzdGVuZXJzKGVsKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5kZXRhaWwpIHtcbiAgICAgICAgICBfdGhpcy4kZW1pdCgnY2hhbmdlJywgZS5kZXRhaWwubnVtYmVyVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzLnZhbHVlID09IG51bGwgJiYgX3RoaXMudmFsdWUgPT0gdW5kZWZpbmVkICYmIF90aGlzLmRlZmF1bHRWYWx1ZSAhPT0gbnVsbCAmJiBfdGhpcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLnZhbHVlQXNJbnRlZ2VyICYmIF90aGlzLmRlZmF1bHRWYWx1ZSA/IF90aGlzLmRlZmF1bHRWYWx1ZSAqIE1hdGgucG93KDEwLCBfdGhpcy5kZWNpbWFsTGVuZ3RoKSA6IF90aGlzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmRldGFpbCAmJiBfdGhpcy52YWx1ZSAhPT0gZS5kZXRhaWwubnVtYmVyVmFsdWUpIHtcbiAgICAgICAgICBfdGhpcy4kZW1pdCgnaW5wdXQnLCBlLmRldGFpbC5udW1iZXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUkMSh2YWx1ZSkge1xuICAgICAgdmFyIGlucHV0ID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcblxuICAgICAgc2V0VmFsdWUoaW5wdXQsIHZhbHVlKTtcbiAgICB9LFxuICAgIGxpc3RlbmVyczogZnVuY3Rpb24gbGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgdmFyIF90aGlzJCRsaXN0ZW5lcnMgPSB0aGlzLiRsaXN0ZW5lcnMsXG4gICAgICAgICAgaW5wdXQgPSBfdGhpcyQkbGlzdGVuZXJzLmlucHV0LFxuICAgICAgICAgIF9rZXl1cCA9IF90aGlzJCRsaXN0ZW5lcnMua2V5dXAsXG4gICAgICAgICAgbGlzdGVuZXJzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJCRsaXN0ZW5lcnMsIFtcImlucHV0XCIsIFwia2V5dXBcIl0pOyAvLyBhbGwgYnV0IGlucHV0IGV2ZW50XG5cblxuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBsaXN0ZW5lcnMpLCB7fSwge1xuICAgICAgICBpbnB1dDogZnVuY3Rpb24gaW5wdXQodmFsdWUpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyLiRyZWZzLnRleHRmaWVsZC5pc1Jlc2V0dGluZyB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBfdGhpczIuc2V0VmFsdWUoX3RoaXMyLnZhbHVlQXNJbnRlZ2VyICYmIF90aGlzMi5kZWZhdWx0VmFsdWUgPyBfdGhpczIuZGVmYXVsdFZhbHVlICogTWF0aC5wb3coMTAsIF90aGlzMi5kZWNpbWFsTGVuZ3RoKSA6IF90aGlzMi5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJ2tleXVwJzogZnVuY3Rpb24ga2V5dXAoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnLScgfHwgZXZlbnQua2V5ID09PSAnKycpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczIudmFsdWUgIT0gbnVsbCAmJiBldmVudC5rZXkgPT09ICctJyAmJiBfdGhpczIudmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgICBfdGhpczIuc2V0VmFsdWUoX3RoaXMyLnZhbHVlICogLTEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoX3RoaXMyLnZhbHVlICE9IG51bGwgJiYgZXZlbnQua2V5ID09PSAnKycgJiYgX3RoaXMyLnZhbHVlIDw9IDApIHtcbiAgICAgICAgICAgICAgX3RoaXMyLnNldFZhbHVlKF90aGlzMi52YWx1ZSAqIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2tleXVwKSB7XG4gICAgICAgICAgICBfa2V5dXAoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50KHRlbXBsYXRlLCBzdHlsZSwgc2NyaXB0LCBzY29wZUlkLCBpc0Z1bmN0aW9uYWxUZW1wbGF0ZSwgbW9kdWxlSWRlbnRpZmllclxuLyogc2VydmVyIG9ubHkgKi9cbiwgc2hhZG93TW9kZSwgY3JlYXRlSW5qZWN0b3IsIGNyZWF0ZUluamVjdG9yU1NSLCBjcmVhdGVJbmplY3RvclNoYWRvdykge1xuICBpZiAodHlwZW9mIHNoYWRvd01vZGUgIT09ICdib29sZWFuJykge1xuICAgIGNyZWF0ZUluamVjdG9yU1NSID0gY3JlYXRlSW5qZWN0b3I7XG4gICAgY3JlYXRlSW5qZWN0b3IgPSBzaGFkb3dNb2RlO1xuICAgIHNoYWRvd01vZGUgPSBmYWxzZTtcbiAgfSAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wLlxuXG5cbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0ID09PSAnZnVuY3Rpb24nID8gc2NyaXB0Lm9wdGlvbnMgOiBzY3JpcHQ7IC8vIHJlbmRlciBmdW5jdGlvbnNcblxuICBpZiAodGVtcGxhdGUgJiYgdGVtcGxhdGUucmVuZGVyKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSB0ZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSB0ZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gICAgb3B0aW9ucy5fY29tcGlsZWQgPSB0cnVlOyAvLyBmdW5jdGlvbmFsIHRlbXBsYXRlXG5cbiAgICBpZiAoaXNGdW5jdGlvbmFsVGVtcGxhdGUpIHtcbiAgICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWU7XG4gICAgfVxuICB9IC8vIHNjb3BlZElkXG5cblxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkO1xuICB9XG5cbiAgdmFyIGhvb2s7XG5cbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHtcbiAgICAvLyBzZXJ2ZXIgYnVpbGRcbiAgICBob29rID0gZnVuY3Rpb24gaG9vayhjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID0gY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCB8fCAvLyBzdGF0ZWZ1bFxuICAgICAgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0OyAvLyBmdW5jdGlvbmFsXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcblxuICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfXztcbiAgICAgIH0gLy8gaW5qZWN0IGNvbXBvbmVudCBzdHlsZXNcblxuXG4gICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgc3R5bGUuY2FsbCh0aGlzLCBjcmVhdGVJbmplY3RvclNTUihjb250ZXh0KSk7XG4gICAgICB9IC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJlbmNlXG5cblxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKG1vZHVsZUlkZW50aWZpZXIpO1xuICAgICAgfVxuICAgIH07IC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXG4gICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcblxuXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rO1xuICB9IGVsc2UgaWYgKHN0eWxlKSB7XG4gICAgaG9vayA9IHNoYWRvd01vZGUgPyBmdW5jdGlvbiAoKSB7XG4gICAgICBzdHlsZS5jYWxsKHRoaXMsIGNyZWF0ZUluamVjdG9yU2hhZG93KHRoaXMuJHJvb3QuJG9wdGlvbnMuc2hhZG93Um9vdCkpO1xuICAgIH0gOiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgc3R5bGUuY2FsbCh0aGlzLCBjcmVhdGVJbmplY3Rvcihjb250ZXh0KSk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChob29rKSB7XG4gICAgaWYgKG9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcblxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24oaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dCk7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlbmRlcihoLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZTtcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spIDogW2hvb2tdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzY3JpcHQ7XG59XG5cbnZhciBub3JtYWxpemVDb21wb25lbnRfMSA9IG5vcm1hbGl6ZUNvbXBvbmVudDtcblxuLyogc2NyaXB0ICovXG5jb25zdCBfX3Z1ZV9zY3JpcHRfXyA9IHNjcmlwdDtcblxuLyogdGVtcGxhdGUgKi9cbnZhciBfX3Z1ZV9yZW5kZXJfXyA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ3YtdGV4dC1maWVsZCcsX3ZtLl9nKF92bS5fYih7ZGlyZWN0aXZlczpbe25hbWU6XCJjdXJyZW5jeS1kaXJlY3RpdmVcIixyYXdOYW1lOlwidi1jdXJyZW5jeS1kaXJlY3RpdmVcIix2YWx1ZTooe2N1cnJlbmN5OiBfdm0uY3VycmVuY3ksIGxvY2FsZTogX3ZtLmxvY2FsZSwgZGlzdHJhY3Rpb25GcmVlOiBfdm0uZGlzdHJhY3Rpb25GcmVlLCBwcmVjaXNpb246IF92bS5kZWNpbWFsTGVuZ3RoLCBhdXRvRGVjaW1hbE1vZGU6IF92bS5kZWNpbWFsTW9kZSwgdmFsdWVSYW5nZTogX3ZtLnZhbHVlUmFuZ2UsIGFsbG93TmVnYXRpdmU6IF92bS5hbGxvd05lZ2F0aXZlLCB2YWx1ZUFzSW50ZWdlcjogX3ZtLnZhbHVlQXNJbnRlZ2VyfSksZXhwcmVzc2lvbjpcIntjdXJyZW5jeSwgbG9jYWxlLCBkaXN0cmFjdGlvbkZyZWUsIHByZWNpc2lvbjogZGVjaW1hbExlbmd0aCwgYXV0b0RlY2ltYWxNb2RlOiBkZWNpbWFsTW9kZSwgdmFsdWVSYW5nZSwgYWxsb3dOZWdhdGl2ZSwgdmFsdWVBc0ludGVnZXJ9XCJ9XSxyZWY6XCJ0ZXh0ZmllbGRcIixhdHRyczp7XCJ0eXBlXCI6XCJ0ZXh0XCJ9LHNjb3BlZFNsb3RzOl92bS5fdShbX3ZtLl9sKChfdm0uJHNsb3RzKSxmdW5jdGlvbihpbmRleCxuYW1lKXtyZXR1cm4ge2tleTpuYW1lLGZuOmZ1bmN0aW9uKCl7cmV0dXJuIFtfdm0uX3QobmFtZSldfSxwcm94eTp0cnVlfX0pXSxudWxsLHRydWUpLG1vZGVsOnt2YWx1ZTooX3ZtLmZvcm1hdHRlZFZhbHVlKSxjYWxsYmFjazpmdW5jdGlvbiAoJCR2KSB7X3ZtLmZvcm1hdHRlZFZhbHVlPSQkdjt9LGV4cHJlc3Npb246XCJmb3JtYXR0ZWRWYWx1ZVwifX0sJ3YtdGV4dC1maWVsZCcsX3ZtLmF0dHJzLGZhbHNlKSxfdm0ubGlzdGVuZXJzKCkpKX07XG52YXIgX192dWVfc3RhdGljUmVuZGVyRm5zX18gPSBbXTtcblxuICAvKiBzdHlsZSAqL1xuICBjb25zdCBfX3Z1ZV9pbmplY3Rfc3R5bGVzX18gPSB1bmRlZmluZWQ7XG4gIC8qIHNjb3BlZCAqL1xuICBjb25zdCBfX3Z1ZV9zY29wZV9pZF9fID0gdW5kZWZpbmVkO1xuICAvKiBtb2R1bGUgaWRlbnRpZmllciAqL1xuICBjb25zdCBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gdW5kZWZpbmVkO1xuICAvKiBmdW5jdGlvbmFsIHRlbXBsYXRlICovXG4gIGNvbnN0IF9fdnVlX2lzX2Z1bmN0aW9uYWxfdGVtcGxhdGVfXyA9IGZhbHNlO1xuICAvKiBzdHlsZSBpbmplY3QgKi9cbiAgXG4gIC8qIHN0eWxlIGluamVjdCBTU1IgKi9cbiAgXG5cbiAgXG4gIHZhciBWQ3VycmVuY3lGaWVsZCA9IG5vcm1hbGl6ZUNvbXBvbmVudF8xKFxuICAgIHsgcmVuZGVyOiBfX3Z1ZV9yZW5kZXJfXywgc3RhdGljUmVuZGVyRm5zOiBfX3Z1ZV9zdGF0aWNSZW5kZXJGbnNfXyB9LFxuICAgIF9fdnVlX2luamVjdF9zdHlsZXNfXyxcbiAgICBfX3Z1ZV9zY3JpcHRfXyxcbiAgICBfX3Z1ZV9zY29wZV9pZF9fLFxuICAgIF9fdnVlX2lzX2Z1bmN0aW9uYWxfdGVtcGxhdGVfXyxcbiAgICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fLFxuICAgIHVuZGVmaW5lZCxcbiAgICB1bmRlZmluZWRcbiAgKTtcblxudmFyIHZlcnNpb24gPSAnMy4xLjEnO1xuXG5mdW5jdGlvbiBpbnN0YWxsKFZ1ZSwgZ2xvYmFsT3B0aW9ucykge1xuICBpZiAoZ2xvYmFsT3B0aW9ucykge1xuICAgIE9iamVjdC5rZXlzKGdsb2JhbE9wdGlvbnMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBvcHRpb25zW2tleV0gPSBnbG9iYWxPcHRpb25zW2tleV07XG4gICAgfSk7XG4gIH1cblxuICBWdWUuY29tcG9uZW50KCd2LWN1cnJlbmN5LWZpZWxkJywgVkN1cnJlbmN5RmllbGQpO1xufVxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlZ1ZSkge1xuICB3aW5kb3cuVnVlLnVzZShpbnN0YWxsKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5zdGFsbDtcbmV4cG9ydCB7IFZDdXJyZW5jeUZpZWxkLCBvcHRpb25zLCB2ZXJzaW9uIH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///./node_modules/v-currency-field/dist/v-currency-field.esm.js\\n\")}}]);","extractedComments":[]}